
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg-flat.dtd" >
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>
      Initiality Project - Overview in nLab
  </title>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="robots" content="index,follow" />


  <link href="/stylesheets/instiki.css?1534097725" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/mathematics.css?1534319116" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/syntax.css?1531905161" media="all" rel="stylesheet" type="text/css" />
  <style type="text/css">
    h1#pageName, div.info, .newWikiWord a, a.existingWikiWord, .newWikiWord a:hover, [actiontype="toggle"]:hover, #TextileHelp h3 {
      color: #008B26;
    }
    a:visited.existingWikiWord {
      color: #005c19;
    }
    
    
  </style>
  
  <style type="text/css"><!--/*--><![CDATA[/*><!--*/
    .toc ul {margin: 0; padding: 0;}
.toc ul ul {margin: 0; padding: 0 0 0 10px;}
.toc li > p {margin: 0}
.toc ul li {list-style-type: none; position: relative;}
.toc div {border-top:1px dotted #ccc;}
.rightHandSide h2 {font-size: 1.5em;color:#008B26}
table.plaintable {
    border-collapse:collapse;
    margin-left:30px;
    border:0;
}
.plaintable td {border:1px solid #000; padding: 3px;}
.plaintable th {padding: 3px;}
.plaintable caption {
    font-weight: bold;
    font-size:1.1em;
    text-align:center;
    margin-left:30px;
}
    
   
/* Query boxes for questioning and answering mechanism */
div.query{
background: #f6fff3;
border: solid #ce9;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
max-height: 20em;
overflow: auto;
}

/* Standout boxes for putting important text */
div.standout{
background: #fff1f1;
border: solid black;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
overflow: auto;
}

/* Icon for links to n-category arXiv documents 
 (commented out for now i.e. disabled)
a[href*="http://arxiv.org/"] {
  background-image: url(../files/arXiv_icon.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 22px;
  } */
    
/* Icon for links to n-category cafe posts (disabled) 
a[href*="http://golem.ph.utexas.edu/category"] {
  background-image: url(../files/n-cafe_5.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pdf files (disabled)
a[href$=".pdf"] {
  background-image: url(../files/pdficon_small.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pages, etc. -inside- pdf files (disabled)
a[href*=".pdf#"] {
  background-image: url(../files/pdf_entry.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

a.existingWikiWord {
color: #005000;
}

a.existingWikiWord:visited {
color: #005000;
}


a.existingWikiWord[title] {
border: 0px;
color: #aa0505;
text-decoration: none;
}
    
a.existingWikiWord[title]:visited {
border: 0px;
color: #551111;
text-decoration: none;
}

a[href^="http://"] {
border: 0px;
color: #003399;
}

a[href^="http://"]:visited {
border: 0px;
color: #330066;
}

a[href^="https://"] {
border: 0px;
color: #003399;
}

a[href^="https://"]:visited {
border: 0px;
color: #330066;
}

div.dropDown .hide {
display: none;
}

div.dropDown:hover .hide {
display:block;
}

div.clickDown .hide {
display: none;
}

div.clickDown:focus {
outline:none;
}

div.clickDown:focus .hide, div.clickDown:hover .hide {
display: block;
}

div.clickDown .clickToReveal, div.clickDown:focus .clickToHide {
display:block;
}

div.clickDown:focus .clickToReveal, div.clickDown .clickToHide {
display:none;
}

div.clickDown .clickToReveal:after {
content: "\A(Hover to reveal, click to \"hold\")";
font-size: 60%;
}

div.clickDown .clickToHide:after {
content: "\A(Click to hide)";
font-size: 60%;
}
div.clickDown .clickToHide, div.clickDown .clickToReveal {
white-space: pre-wrap;
}

.un_theorem, .num_theorem, .un_lemma, .num_lemma, .un_prop, .num_prop, .un_cor, .num_cor, .un_defn, .num_defn, .un_example, .num_example, .un_note, .num_note, .un_remark, .num_remark {
margin-left: 1em;
}

span.theorem_label {
margin-left: -1em;
}
.proof span.theorem_label {
margin-left: 0em;
}
:target {
    background-color: #BBBBBB;
    border-radius: 5pt;
    padding: 0 10pt;
}
    
    
    
    
    
    
    
    
    
    
    
  /*]]>*/--></style>
  <script src="/javascripts/prototype.js?1532905251" type="text/javascript"></script>
<script src="/javascripts/effects.js?1532905251" type="text/javascript"></script>
<script src="/javascripts/dragdrop.js?1532905252" type="text/javascript"></script>
<script src="/javascripts/controls.js?1532905250" type="text/javascript"></script>
<script src="/javascripts/application.js?1532905250" type="text/javascript"></script>
  <script src="/javascripts/page_helper.js?1533109147" type="text/javascript"></script>
  <script src="/javascripts/thm_numbering.js?1533108238" type="text/javascript"></script>
  
  <script type="text/x-mathjax-config">
  <!--//--><![CDATA[//><!--
    MathJax.Ajax.config.path["Contrib"] = "/MathJax";
    MathJax.Hub.Config({
      MathML: { useMathMLspacing: true },
      "HTML-CSS": { scale: 90,
                    extensions: ["handle-floats.js"]
      }
    });
    MathJax.Hub.Queue( function () {
       var fos = document.getElementsByTagName('foreignObject');
       for (var i = 0; i < fos.length; i++) {
         MathJax.Hub.Typeset(fos[i]);
       }
    });
  //--><!]]>
  </script>

  <script type="text/javascript">
    <!--//--><![CDATA[//><!--
    window.addEventListener("DOMContentLoaded", function () {
      var div = document.createElement('div');
      var math = document.createElementNS('http://www.w3.org/1998/Math/MathML', 'math');
      document.body.appendChild(div);
      div.appendChild(math);
    // Test for MathML support comparable to WebKit version https://trac.webkit.org/changeset/203640 or higher.
      div.setAttribute('style', 'font-style: italic');
      var mathml_unsupported = !(window.getComputedStyle(div.firstChild).getPropertyValue('font-style') === 'normal');
      div.parentNode.removeChild(div);
      if (mathml_unsupported) {
        // MathML does not seem to be supported...
        var s = document.createElement('script');
        s.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=MML_HTMLorMML-full";
        document.querySelector('head').appendChild(s);
      } else {
        document.head.insertAdjacentHTML("beforeend", '<style>svg[viewBox] {max-width: 100%}</style>');
      }
    });
    //--><!]]>
  </script>

  	<link href="https://ncatlab.org/nlab/atom_with_headlines" rel="alternate" title="Atom with headlines" type="application/atom+xml" />
  	<link href="https://ncatlab.org/nlab/atom_with_content" rel="alternate" title="Atom with full content" type="application/atom+xml" />
  <script type="text/javascript">
  document.observe("dom:loaded", function() {
    generateThmNumbers();
  });
  </script>
</head>

<body>

<div id="Container">
<div id="Content">
  <h1 id="pageName">
    
<span id="svg_logo"><svg version="1.1" width="100%" height="100%" viewBox='0 -1 180 198' xmlns='http://www.w3.org/2000/svg'>
      <path id="svg_logo_path" fill="#008B26" stroke-width='0.5' stroke='#000' d='
        M170,60c4,11-1,20-12,25c-9,4-25,3-20,15c5,5,15,0,24,1c11,1,21,11,14,21c-10,15-35,6-48-1c-5-3-27-23-32-10c-1,13,15,10,22,16
        c11,4,24,14,34,20c12,10,7,25-9,23c-11-1-22-9-30-16c-5-5-13-18-21-9c-2,6,2,11,5,14c9,9,22,14,22,31c-2,8-12,8-18,4c-4-3-9-8-11-13
        c-3-6-5-18-12-18c-14-1-5,28-18,30c-9,2-13-9-12-16c1-14,12-24,21-31c5-4,17-13,10-20c-9-10-19,12-23,16c-7,7-17,16-31,15
        c-9-1-18-9-11-17c5-7,14-4,23-6c6-1,15-8,8-15c-5-6-57,2-42-24c7-12,51,4,61,6c6,1,17,4,18-4c2-11-12-7-21-8c-21-2-49-14-49-34
        c0-5,3-11,8-11C31,42,34,65,42,67c6,1,9-3,8-9C49,49,38,40,40,25c1-5,4-15,13-14c10,2,11,18,13,29c1,8,0,24,7,28c15,0,5-22,4-30
        C74,23,78,7,87,1c8-4,14,1,16,9c2,11-8,21-2,30c8,2,11-6,14-12c9-14,36-18,30,5c-3,9-12,19-21,24c-6,4-22,10-23,19c-2,14,15,2,18-2
        c9-9,20-18,33-22C159,52,166,54,170,60' />
    </svg></span>
      <span class="webName">nLab</span><br />
      Initiality Project - Overview
  </h1>



<div class="navigation">
    <span class="skipNav"><a href='#navEnd'>Skip the Navigation Links</a> | </span>
    <a href="/nlab/show/HomePage" accesskey="H" title="Home page">Home Page</a> |
    <a href="/nlab/all_pages" accesskey="A" title="List of all pages">All Pages</a> |
    <a href="/nlab/latest_revisions" accesskey="U" title="Latest edits and page creations">Latest Revisions</a> |
    <a href="https://nforum.ncatlab.org/discussion/9158/#Item_2" title="Discuss this page in its dedicated thread on the nForum" style="color: black">Discuss this page</a> |
    <a href="/nlab/feeds" title="Subscribe to changes by Atom">Feeds</a> |
<form accept-charset="utf-8" action="/nlab/search" id="navigationSearchForm" method="get">      <fieldset class="search"><input type="text" id="searchField" name="query" value="Search"
             onfocus="this.value == 'Search' ? this.value = '' : true"
             onblur="this.value == '' ? this.value = 'Search' : true" /></fieldset>
</form>  <span id='navEnd'></span>
</div>






<div id="revision">
    <html xmlns="http://www.w3.org/1999/xhtml" xmlns:svg="http://www.w3.org/2000/svg" xml:lang="en" lang="en">
<head><meta http-equiv="Content-type" content="application/xhtml+xml;charset=utf-8" /><title>Initiality Project - Overview</title></head>
<body>
<h1 id="initiality_project__overview">Initiality Project - Overview</h1>

<p>This page is part of the <a class="existingWikiWord" href="/nlab/show/Initiality+Project">Initiality Project</a>.</p>

<p>Here is a proposed slate of choices to make regarding type theories, presentations, definitions, and proof structure. (“I” refers to <a class="existingWikiWord" href="/nlab/show/Mike+Shulman">Mike Shulman</a>.) This is only a first proposal and may change; discussion is underway at the nForum <a href="https://nforum.ncatlab.org/discussion/9160/initiality-project-plans/">here</a>.</p>
<div class='maruku_toc'>
<ul>
<li><a href='#Semantics'>The semantics</a></li>
<li><a href='#the_type_theory'>The type theory</a></li>
<ul>
<li><a href='#axioms'>Axioms</a></li>
<li><a href='#raw_syntax'>Raw syntax</a></li>
<li><a href='#bidirectionality'>Bidirectionality</a></li>
</ul>
<li><a href='#the_proof'>The proof</a></li>
<ul>
<li><a href='#the_partial_interpretation'>The partial interpretation</a></li>
<li><a href='#totality_of_the_interpretation'>Totality of the interpretation</a></li>
<li><a href='#loose_ends'>Loose ends</a></li>
</ul>
</ul>
</div>

<h2 id="Semantics">The semantics</h2>

<p>Of the various ways to describe a <a class="existingWikiWord" href="/nlab/show/categorical+model+of+dependent+types">categorical model of dependent types</a>, I suggest to use <em>categories with families</em>, presented in the style called by <a class="existingWikiWord" href="/nlab/show/Steve+Awodey">Awodey</a> a <a href="https://arxiv.org/abs/1406.3219">natural model</a>, but fully algebraically. That is, for us a category with families is a (small) <a class="existingWikiWord" href="/nlab/show/category">category</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math> together with two <a class="existingWikiWord" href="/nlab/show/presheaves">presheaves</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Tm</mi><mo>,</mo><mi>Ty</mi><mo>∈</mo><mo stretchy="false">[</mo><msup><mi>C</mi> <mi>op</mi></msup><mo>,</mo><mi>Set</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">Tm,Ty \in [C^{op},Set]</annotation></semantics></math> and a morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Tm</mi><mo>→</mo><mi>Ty</mi></mrow><annotation encoding="application/x-tex">Tm \to Ty</annotation></semantics></math> that is <em>algebraically representable</em> (or, one might say, “represented”): it is equipped with a <em>function</em> assigning to each morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>:</mo><mi>y</mi><mi>Γ</mi><mo>→</mo><mi>Ty</mi></mrow><annotation encoding="application/x-tex">A:y \Gamma \to Ty</annotation></semantics></math>, where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>∈</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">\Gamma\in C</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math> denotes the <a class="existingWikiWord" href="/nlab/show/Yoneda+embedding">Yoneda embedding</a>, an object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>.</mo><mi>A</mi><mo>∈</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">\Gamma.A\in C</annotation></semantics></math> and a <a class="existingWikiWord" href="/nlab/show/pullback+square">pullback square</a></p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><mi>y</mi><mo stretchy="false">(</mo><mi>Γ</mi><mo>.</mo><mi>A</mi><mo stretchy="false">)</mo></mtd> <mtd><mo>→</mo></mtd> <mtd><mi>Tm</mi></mtd></mtr> <mtr><mtd><mo stretchy="false">↓</mo></mtd> <mtd></mtd> <mtd><mo stretchy="false">↓</mo></mtd></mtr> <mtr><mtd><mi>y</mi><mi>Γ</mi></mtd> <mtd><mover><mo>→</mo><mi>A</mi></mover></mtd> <mtd><mi>Ty</mi><mo>.</mo></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\array{ y(\Gamma.A) &amp; \to &amp; Tm \\ \downarrow &amp;&amp;\downarrow \\ y\Gamma &amp; \xrightarrow{A} &amp; Ty. } </annotation></semantics></math></div>
<p>This is equivalent to the usual notion of category with families (and thereby also to the usual notion of “category with attributes”, hence also to discrete or full split comprehension categories). But, as noted by Awodey, focusing attention on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Tm</mi></mrow><annotation encoding="application/x-tex">Tm</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Ty</mi></mrow><annotation encoding="application/x-tex">Ty</annotation></semantics></math> as objects of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><msup><mi>C</mi> <mi>op</mi></msup><mo>,</mo><mi>Set</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[C^{op},Set]</annotation></semantics></math> has the advantage that the additional structure corresponding to the rules of a type theory are also naturally formulated in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><msup><mi>C</mi> <mi>op</mi></msup><mo>,</mo><mi>Set</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[C^{op},Set]</annotation></semantics></math>. For instance, if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>Ty</mi> <mn>2</mn></msup></mrow><annotation encoding="application/x-tex">Ty^2</annotation></semantics></math> denotes the domain of the local exponential <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>Ty</mi><mo>×</mo><mi>Ty</mi><mo>→</mo><mi>Ty</mi><msup><mo stretchy="false">)</mo> <mrow><mo stretchy="false">(</mo><mi>Tm</mi><mo>→</mo><mi>Ty</mi><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">(Ty\times Ty \to Ty)^{(Tm\to Ty)}</annotation></semantics></math>, then the rules of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>-formation and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math>-formation correspond semantically to giving a morphism <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>Ty</mi> <mn>2</mn></msup><mo>→</mo><mi>Ty</mi></mrow><annotation encoding="application/x-tex">Ty^2 \to Ty</annotation></semantics></math>.</p>

<p>Note also that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>Ty</mi> <mn>2</mn></msup></mrow><annotation encoding="application/x-tex">Ty^2</annotation></semantics></math> can be described in the internal extensional type theory of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><msup><mi>C</mi> <mi>op</mi></msup><mo>,</mo><mi>Set</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[C^{op},Set]</annotation></semantics></math> by the context <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>:</mo><mi>Ty</mi><mo>,</mo><mi>B</mi><mo>:</mo><mi>Tm</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>→</mo><mi>Ty</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A:Ty, B:Tm(A) \to Ty)</annotation></semantics></math>; thus <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><msup><mi>C</mi> <mi>op</mi></msup><mo>,</mo><mi>Set</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[C^{op},Set]</annotation></semantics></math> is a sort of “semantic <a class="existingWikiWord" href="/nlab/show/logical+framework">logical framework</a>” for structuring <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>. My inclination right now is that while we can rely on this for intuition and explanation, we should also formulate all this structure precisely in traditional category-theoretic language, to avoid any appearance of circularity in our construction of categorical models of dependent type theory.</p>

<p>A <em>morphism of categories with families</em> is a functor <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>F</mi><mo>:</mo><mi>C</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">F:C\to D</annotation></semantics></math> together with a commutative square in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><msup><mi>C</mi> <mi>op</mi></msup><mo>,</mo><mi>Set</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[C^{op},Set]</annotation></semantics></math>:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mrow><mtable><mtr><mtd><msub><mi>Tm</mi> <mi>C</mi></msub></mtd> <mtd><mo>→</mo></mtd> <mtd><msup><mi>F</mi> <mo>*</mo></msup><mo stretchy="false">(</mo><msub><mi>Tm</mi> <mi>D</mi></msub><mo stretchy="false">)</mo></mtd></mtr> <mtr><mtd><mo stretchy="false">↓</mo></mtd> <mtd></mtd> <mtd><mo stretchy="false">↓</mo></mtd></mtr> <mtr><mtd><msub><mi>Ty</mi> <mi>C</mi></msub></mtd> <mtd><mo>→</mo></mtd> <mtd><msup><mi>F</mi> <mo>*</mo></msup><mo stretchy="false">(</mo><msub><mi>Ty</mi> <mi>D</mi></msub><mo stretchy="false">)</mo></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\array{ Tm_C &amp; \to &amp; F^*(Tm_D) \\ \downarrow &amp; &amp; \downarrow \\ Ty_C &amp; \to &amp; F^*(Ty_D) }</annotation></semantics></math></div>
<p>which strictly respects the chosen pullback squares in an appropriate way. This defines the category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>CwF</mi></mrow><annotation encoding="application/x-tex">CwF</annotation></semantics></math> in which we hope to construct an initial object.</p>

<h2 id="the_type_theory">The type theory</h2>

<p>I suggest to start with a type theory containing only <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math>-types. This seems the simplest situation where we will have to deal with all the basic issues. We can then add additional structure as desired.</p>

<h3 id="axioms">Axioms</h3>

<p>Note that this type theory is completely empty unless we also assert some axioms. Ideally, I would like the “initiality theorem” to really be a “freeness theorem”, saying that the syntactic category of a type theory with axioms is freely generated by those axioms. Of course, particular axioms can just be added as rules to a theory, but such a general freeness theorem should be parametric over all possible axioms.</p>

<p>Since in a dependent type theory, each axiom can involve previous axioms in its type, it seems that the general semantic formulation will have to involve some kind of a “cell complex” in the category <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>CwF</mi></mrow><annotation encoding="application/x-tex">CwF</annotation></semantics></math>. However, we can leave this to the future for the moment and concentrate on the inductive clauses for interpreting the basic rules of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math>-types.</p>

<h3 id="raw_syntax">Raw syntax</h3>

<p>I propose to use syntax with named variables, quotiented by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>-equivalence. My reason is that our goal is expositional and sociological, and named variables keep the syntax as close as possible to what “users” of type theory are familiar with. Since we are humans writing for humans to read, I don’t want to deal explicitly with de Bruijn indices, and neither do I want to pretend that we are using de Bruijn indices when we aren’t <em>really</em> using them.</p>

<p>If this proposal is adopted, then the raw terms for our simple type theory will be inductively generated by:</p>

<ul>
<li>Every variable <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> is a term.</li>

<li>If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>,</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A,B</annotation></semantics></math> are terms and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> is a variable, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">)</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\Pi(x:A) B</annotation></semantics></math> is a term.</li>

<li>If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>,</mo><mi>B</mi><mo>,</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">A,B,M</annotation></semantics></math> are terms and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> is a variable, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">)</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\lambda(x:A.B)M</annotation></semantics></math> is a term.</li>

<li>If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>,</mo><mi>B</mi><mo>,</mo><mi>M</mi><mo>,</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">A,B,M,N</annotation></semantics></math> are terms and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> is a variable, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>App</mi> <mrow><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">)</mo><mi>B</mi></mrow></msup><mo stretchy="false">(</mo><mi>M</mi><mo>,</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">App^{(x:A)B}(M,N)</annotation></semantics></math> is a term.</li>
</ul>

<p>We define <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>-equivalence which renames bound variables as usual. Note that the variable <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">)</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\Pi(x:A)B</annotation></semantics></math> scopes only over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math>, in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">)</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\lambda(x:A.B)M</annotation></semantics></math> it scopes only over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>, and in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>App</mi> <mrow><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">)</mo><mi>B</mi></mrow></msup><mo stretchy="false">(</mo><mi>M</mi><mo>,</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">App^{(x:A)B}(M,N)</annotation></semantics></math> it scopes only over <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math>. Capture-avoiding substitution is likewise defined as usual. Our partial interpretation will be defined recursively over the above inductive definition of terms, and proven to respect <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>-equivalence.</p>

<h3 id="bidirectionality">Bidirectionality</h3>

<p>Following Streicher, all our terms are fully (or at least “sufficiently”) annotated. For instance, we write <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>App</mi> <mrow><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">)</mo><mi>B</mi></mrow></msup><mo stretchy="false">(</mo><mi>M</mi><mo>,</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">App^{(x:A)B}(M,N)</annotation></semantics></math> rather than just <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>App</mi><mo stretchy="false">(</mo><mi>M</mi><mo>,</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">App(M,N)</annotation></semantics></math>. (It is, at best, unclear whether any less than fully annotated syntax can be used in an initiality theorem without preprocessing that is tantamount to annotating it.)</p>

<p>In particular, this means that given <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math>, if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>⊢</mo><mi>t</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\Gamma \vdash t:A</annotation></semantics></math> can be derived for any value of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>, then there is a canonical such <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> that can be deduced syntactically, or <em>synthesized</em>, from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math>. For instance, if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>App</mi> <mrow><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">)</mo><mi>B</mi></mrow></msup><mo stretchy="false">(</mo><mi>M</mi><mo>,</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">App^{(x:A)B}(M,N)</annotation></semantics></math> has any type, then it must have the type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">B[N/x]</annotation></semantics></math>. On the other hand, the conversion rule implies that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>App</mi> <mrow><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">)</mo><mi>B</mi></mrow></msup><mo stretchy="false">(</mo><mi>M</mi><mo>,</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">App^{(x:A)B}(M,N)</annotation></semantics></math> must also have any type that is judgmentally <em>equal</em> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">B[N/x]</annotation></semantics></math>.</p>

<p>Type theorists have a standard technique for distinguishing these two situations, known as <a class="existingWikiWord" href="/nlab/show/bidirectional+typechecking">bidirectional typechecking</a>. Instead of one judgment <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>⊢</mo><mi>t</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\Gamma\vdash t:A</annotation></semantics></math>, we have two typing judgments:</p>

<ul>
<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>⊢</mo><mi>t</mi><mo>⇒</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\Gamma \vdash t \Rightarrow A</annotation></semantics></math>: in context <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math> the term <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math> <em>synthesizes</em> the type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>. Here <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> is, if it exists, uniquely determined by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math>: it is an “output” to their “inputs”.</li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>⊢</mo><mi>t</mi><mo>⇐</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\Gamma \vdash t \Leftarrow A</annotation></semantics></math>: in context <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math> the term <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math> <em>checks against</em> the type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>. Here <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> are all “inputs” and the only “output” is the truth value of whether the typecheck is valid.</li>
</ul>

<p>There are various advantages of bidirectional typechecking, including:</p>

<ol>
<li>In at least some cases, it permits a formulation of type theory in which only normal forms exist.</li>

<li>In at least some cases, it allows omission of annotations, e.g. an un-annotated abstraction <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi><mi>x</mi><mo>.</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\lambda x.M</annotation></semantics></math> cannot synthesize a type, but it can check against a <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math>-type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">)</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\Pi(x:A) B</annotation></semantics></math>.</li>

<li>In at least some cases, it makes it easier to incorporate <a class="existingWikiWord" href="/nlab/show/%CE%B7-expansion">η-expansion</a> into an equality-checking algorithm.</li>

<li>In at least some cases, it makes derivations of judgments unique, or at least canonical.</li>

<li>In at least some cases, it isolates the use of judgmental equality during typechecking in one particular “mode-switching” rule:<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>t</mi><mo>⇒</mo><mi>A</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mo>≡</mo><mi>B</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>t</mi><mo>⇐</mo><mi>B</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex"> \frac{\Gamma \vdash t \Rightarrow A \qquad \Gamma \vdash A\equiv B}{\Gamma \vdash t \Leftarrow B} </annotation></semantics></math></div></li>
</ol>

<p>(Experts, feel free to add more.) It is unclear at present whether any of these advantages are relevant to categorical semantics, but by using a bidirectional framework we are better placed to take advantage of them if they do become relevant. More importantly, it seems to me that the natural structure of the semantic interpretation, as suggested by <a class="existingWikiWord" href="/nlab/show/Peter+Lumsdaine">Peter Lumsdaine</a> (see below), matches the syntactic bidirectional picture quite closely, and it may be clarifying to make that analogy more precise.</p>

<p>Since all our terms are fully annotated, all of our formation, introduction, and elimination rules can synthesize their types. However, their <em>premises</em> usually involve <em>checking</em> their subterms against appropriate types, so the above mode-switching rule gets applied a lot (it is the only way, in our system, to derive a checking judgment). This might be an issue to want to optimize away in an implementation, but for our semantic purposes it seems irrelevant.</p>

<p>For instance, here are the formation, introduction, and elimination rules for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math>-types:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>Π</mi><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">)</mo><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">
\frac{\Gamma \vdash A \, type \qquad \Gamma, x:A \vdash B\,type}{\Gamma \vdash \Pi(x:A) B \, type}

</annotation></semantics></math></div><div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>M</mi><mo>⇐</mo><mi>Π</mi><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">)</mo><mi>B</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>N</mi><mo>⇐</mo><mi>A</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><msup><mi>App</mi> <mrow><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">)</mo><mi>B</mi></mrow></msup><mo stretchy="false">(</mo><mi>M</mi><mo>,</mo><mi>N</mi><mo stretchy="false">)</mo><mo>⇒</mo><mi>B</mi><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">
\frac{\Gamma \vdash A \, type \qquad \Gamma, x:A \vdash B\,type \qquad \Gamma \vdash M \Leftarrow \Pi(x:A) B \qquad \Gamma \vdash N \Leftarrow A}{\Gamma \vdash App^{(x:A)B}(M,N) \Rightarrow B[N/x]}

</annotation></semantics></math></div><div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi><mspace width="2em"></mspace><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>M</mi><mo>⇐</mo><mi>B</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>λ</mi><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">)</mo><mi>M</mi><mo>⇒</mo><mi>Π</mi><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">)</mo><mi>B</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">
\frac{\Gamma \vdash A \, type \qquad \Gamma,x:A \vdash B \,type \qquad \Gamma,x:A \vdash M \Leftarrow B}{\Gamma \vdash \lambda(x:A.B)M \Rightarrow \Pi(x:A) B}

</annotation></semantics></math></div>
<p>(Note that the “is a type” judgment <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">\Gamma \vdash A\,type</annotation></semantics></math> is not bidirectional. With Russell universes we could consider making it so.)</p>

<p>The “hypothesis” rule is that a variable in the context synthesizes its assumed type:</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><mfrac><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>Γ</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>x</mi><mo>⇒</mo><mi>A</mi><mo>.</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{(x:A) \in \Gamma}{\Gamma \vdash x \Rightarrow A.}</annotation></semantics></math></div>
<p>In implementations of bidirectional typechecking, the equality judgments <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>⊢</mo><mi>s</mi><mo>≡</mo><mi>t</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\Gamma \vdash s\equiv t : A</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mo>≡</mo><mi>B</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">\Gamma \vdash A \equiv B \, type</annotation></semantics></math> are sometimes made bidirectional as well. But at the moment, I don’t think there will be is any benefit to us in doing likewise. In particular, we would like our setup to be general enough to encompass type theories whose judgmental equality is “poorly behaved”, e.g. undecidable, such as those with an <a class="existingWikiWord" href="/nlab/show/extensional+type+theory">equality reflection rule</a>. Thus the equality judgments should have primitive rules asserting reflexivity, symmetry, transitivity, and congruence properties.</p>

<p>Streicher also includes a basic judgment for equality of <em>contexts</em>. Peter <a href="https://nforum.ncatlab.org/discussion/8904/a-communal-proof-of-an-initiality-theorem/?Focus=71254#Comment_71254">suggests</a> that that isn’t necessary, because</p>

<blockquote>
<p>any contexts that <em>would</em> be judgementally equal in the system with that judgement still end up canonically end up judgementally isomorphic, by the substitution that consists of not renaming variables.</p>
</blockquote>

<p>I’m inclined to follow Peter’s suggestion here, but am open to counterarguments.</p>

<p>Streicher also includes a number of explicit primitive rules involving things like validity of contexts and type-preservation by substitution. I’m not sure whether these are necessary or not; it seems that maybe by presenting our type theories in “the usual way” we should always be able to ensure that substitution is admissible, even for type theories that are “ill-behaved” in other ways (such as equality reflection). But maybe there are good reasons to include these rules explicitly?</p>

<h2 id="the_proof">The proof</h2>

<p>The following proposal for the inductive structure of the argument is based on Streicher’s original approach, with a modification suggested by <a href="https://nforum.ncatlab.org/discussion/8904/a-communal-proof-of-an-initiality-theorem/?Focus=71254#Comment_71254">Peter Lumsdaine</a>, and further tweaks to incorporate bidirectionality and build in naturality using the natural-models technology.</p>

<h3 id="the_partial_interpretation">The partial interpretation</h3>

<p>Given a finite set of variables <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub><mo stretchy="false">}</mo><mo>⊆</mo><mi>Var</mi></mrow><annotation encoding="application/x-tex">V = \{x_1,\dots,x_n\} \subseteq Var</annotation></semantics></math>, the <em>presheaf of environments</em> for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>Tm</mi> <mi>V</mi></msup></mrow><annotation encoding="application/x-tex">Tm^V</annotation></semantics></math>. We will define, by structural induction on any term <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math>, and any any finite set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> of variables, the following partial morphisms of presheaves.</p>

<ol>
<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo lspace="0em" rspace="thinmathspace">&#x27E6;</mo><mi>t</mi><msubsup><mo lspace="0em" rspace="thinmathspace">&#x27E7;</mo> <mi>type</mi> <mi>V</mi></msubsup><mo>:</mo><msup><mi>Tm</mi> <mi>V</mi></msup><mo>⇀</mo><mi>Ty</mi></mrow><annotation encoding="application/x-tex">\llbracket t \rrbracket ^V_{type} : Tm^V \rightharpoonup Ty</annotation></semantics></math>.</li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo lspace="0em" rspace="thinmathspace">&#x27E6;</mo><mi>t</mi><msubsup><mo lspace="0em" rspace="thinmathspace">&#x27E7;</mo> <mo>⇒</mo> <mi>V</mi></msubsup><mo>:</mo><msup><mi>Tm</mi> <mi>V</mi></msup><mo>⇀</mo><mi>Tm</mi></mrow><annotation encoding="application/x-tex">\llbracket t \rrbracket ^V_{\Rightarrow} : Tm^V \rightharpoonup Tm</annotation></semantics></math>.</li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo lspace="0em" rspace="thinmathspace">&#x27E6;</mo><mi>t</mi><msubsup><mo lspace="0em" rspace="thinmathspace">&#x27E7;</mo> <mo>⇐</mo> <mi>V</mi></msubsup><mo>:</mo><msup><mi>Tm</mi> <mi>V</mi></msup><mo>×</mo><mi>Ty</mi><mo>⇀</mo><mi>Tm</mi></mrow><annotation encoding="application/x-tex">\llbracket t \rrbracket ^V_{\Leftarrow} : Tm^V \times Ty \rightharpoonup Tm</annotation></semantics></math> such that the composite <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>Tm</mi> <mi>V</mi></msup><mo>×</mo><mi>Ty</mi><mo>⇀</mo><mi>Tm</mi><mo>→</mo><mi>Ty</mi></mrow><annotation encoding="application/x-tex">Tm^V \times Ty \rightharpoonup Tm \to Ty</annotation></semantics></math> is the second projection.</li>
</ol>

<p>In fact, the third of these is not actually inductive at all: it is simply a semantic counterpart of the bidirectional mode-switching judgment. We define <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo lspace="0em" rspace="thinmathspace">&#x27E6;</mo><mi>t</mi><msubsup><mo lspace="0em" rspace="thinmathspace">&#x27E7;</mo> <mo>⇐</mo> <mi>V</mi></msubsup></mrow><annotation encoding="application/x-tex">\llbracket t \rrbracket ^V_{\Leftarrow}</annotation></semantics></math> to be the domain restriction of</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msup><mi>Tm</mi> <mi>V</mi></msup><mo>×</mo><mi>Ty</mi><mover><mo>→</mo><mrow><msub><mi>pr</mi> <mn>1</mn></msub></mrow></mover><msup><mi>Tm</mi> <mi>V</mi></msup><mover><mo>⇀</mo><mrow><mo lspace="0em" rspace="thinmathspace">&#x27E6;</mo><mi>t</mi><msubsup><mo lspace="0em" rspace="thinmathspace">&#x27E7;</mo> <mo>⇒</mo> <mi>V</mi></msubsup></mrow></mover><mi>Tm</mi></mrow><annotation encoding="application/x-tex"> Tm^V \times Ty \xrightarrow{pr_1} Tm^V \overset{\llbracket t \rrbracket ^V_{\Rightarrow}}{\rightharpoonup} Tm </annotation></semantics></math></div>
<p>to the equalizer of</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msup><mi>Tm</mi> <mi>V</mi></msup><mo>×</mo><mi>Ty</mi><mover><mo>→</mo><mrow><msub><mi>pr</mi> <mn>1</mn></msub></mrow></mover><msup><mi>Tm</mi> <mi>V</mi></msup><mover><mo>⇀</mo><mrow><mo lspace="0em" rspace="thinmathspace">&#x27E6;</mo><mi>t</mi><msubsup><mo lspace="0em" rspace="thinmathspace">&#x27E7;</mo> <mo>⇒</mo> <mi>V</mi></msubsup></mrow></mover><mi>Tm</mi><mo>→</mo><mi>Ty</mi></mrow><annotation encoding="application/x-tex"> Tm^V \times Ty \xrightarrow{pr_1} Tm^V \overset{\llbracket t \rrbracket ^V_{\Rightarrow}}{\rightharpoonup} Tm \to Ty </annotation></semantics></math></div>
<p>and the restriction of the second projection <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>Tm</mi> <mi>V</mi></msup><mo>×</mo><mi>Ty</mi></mrow><annotation encoding="application/x-tex">Tm^V \times Ty</annotation></semantics></math> to its domain.</p>

<p>The other inductive clauses of the partial interpretation should precisely mirror the bidirectional rules of our type theory, using recursive calls to the above three operations as counterparts of the three syntactic judgments <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="thinmathspace"></mspace><mi>type</mi></mrow><annotation encoding="application/x-tex">\Gamma \vdash A\,type</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>⊢</mo><mi>t</mi><mo>⇒</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\Gamma \vdash t\Rightarrow A</annotation></semantics></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi><mo>⊢</mo><mi>t</mi><mo>⇐</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\Gamma \vdash t\Leftarrow A</annotation></semantics></math>. Note, though, that at this point this is only an analogy: we are simply inducting over the raw term structure of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math>, not making any actual reference to these judgments.</p>

<p>This suggestion incorporates the innovation proposed by <a href="https://nforum.ncatlab.org/discussion/8904/a-communal-proof-of-an-initiality-theorem/?Focus=71254#Comment_71254">Peter</a> over Streicher’s proof of taking the interpretation of the context <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math> as an <em>input</em> to the partial intepretation functions rather than an output (see in particular his point (7)). The elements of the presheaf <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>Tm</mi> <mi>V</mi></msup></mrow><annotation encoding="application/x-tex">Tm^V</annotation></semantics></math> at some object <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>∈</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">X\in C</annotation></semantics></math> are what Peter calls “environments” for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math>. Note that we do not require that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> contain all free variables occurring in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math>, but if it omits some then the partial interpretation morphisms should turn out to have empty domain.</p>

<p>I have also reformulated the interpretation function to “put naturality into the goals of the original induction” as suggested by Peter in his point (8), by directly defining partial morphisms in the “semantic logical framework” <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><msup><mi>C</mi> <mi>op</mi></msup><mo>,</mo><mi>Set</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[C^{op},Set]</annotation></semantics></math>. This has the additional advantage that in writing down the inductive clauses we can refer directly to the natural-models formulation of the corresponding structure on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>, as sketched <a href="#Semantics">above</a>.</p>

<h3 id="totality_of_the_interpretation">Totality of the interpretation</h3>

<p>Although the partial interpretation functions sketched above incorporate a number of “tweaks” to make it more pleasing, in fact it was already the short part: Streicher does it in only 5 pages. (His pages are very short, so this isn’t actually very much, plus his type theory is more complicated.) The long part is proving that these interpretation functions are total on derivable judgments; this takes Streicher 40 pages.</p>

<p>The outline should be the same as in Streicher’s proof and Peter’s proposal:</p>

<ol>
<li>
<p>Prove by induction on raw terms that the partial interpretation functions take syntactic substitution (including weakening) to semantic substitution (restriction in the presheaves <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Tm</mi></mrow><annotation encoding="application/x-tex">Tm</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Ty</mi></mrow><annotation encoding="application/x-tex">Ty</annotation></semantics></math>). This takes Streicher 17 pages.</p>
</li>

<li>
<p>Prove by induction on derivations that the partial interpretation functions are total on derivable judgments. This takes Streicher 20 pages.</p>
</li>
</ol>

<h3 id="loose_ends">Loose ends</h3>

<p>To complete the proof of initiality after this, it remains to:</p>

<ol>
<li>
<p>Construct the term model. This takes Streicher 12 pages.</p>
</li>

<li>
<p>Show that the above interpretation assembles into a morphism in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>CwF</mi></mrow><annotation encoding="application/x-tex">CwF</annotation></semantics></math> from the term model to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math>. As far as I can tell, Streicher doesn’t actually do this, he just claims that it can be done.</p>
</li>

<li>
<p>Show that this morphism is unique. Streicher doesn’t actually do this either.</p>
</li>
</ol>
<div class="property">category: <a class="category_link" href="/nlab/all_pages/Initiality+Project">Initiality Project</a></div></body></html>

</div>

<div class="revisedby">
  <p>
  Last revised on January  7, 2019 at 15:49:45.
  See the <a href="https://ncatlab.org/nlab/history/Initiality Project - Overview" style="color: #005c19">history</a> of this page for a list of all contributions to it.
  </p>
</div>

<div class="navigation navfoot">

  <a href="/nlab/edit/Initiality+Project+-+Overview" accesskey="E" class="navlink" id="edit" rel="nofollow">Edit</a> | <a href="/nlab/revision/Initiality+Project+-+Overview/5" accesskey="B" class="navlink" id="to_previous_revision" rel="nofollow">Back in time</a> <span class='revisions'>(5 revisions)</span> | <a href="/nlab/show/diff/Initiality+Project+-+Overview" accesskey="C" class="navlink" id="see_changes" rel="nofollow">See changes</a> | <a href="/nlab/history/Initiality+Project+-+Overview" accesskey="S" class="navlink" id="history" rel="nofollow">History</a>
  | <a href="https://ncatlab.org/nlab/show/Initiality Project - Overview/cite" style="color: black">Cite</a>
  <span class="views">
    | Views:
    <a href="/nlab/print/Initiality+Project+-+Overview" accesskey="p" id="view_print" rel="nofollow">Print</a>
    |
    <a href="/nlab/tex/Initiality+Project+-+Overview" id="view_tex" rel="nofollow">TeX</a>
    |
    <a href="/nlab/source/Initiality+Project+-+Overview" id="view_source" rel="nofollow">Source</a>
  </span>

  


</div>


    <div id="footer">
    <div>This site is running on <a href="http://golem.ph.utexas.edu/instiki/show/HomePage">Instiki 0.19.7(MML+)</a></div>
    <div>Powered by <a href="http://rubyonrails.com/">Ruby on Rails</a>  2.3.18</div>
    </div>

</div> <!-- Content -->

</div> <!-- Container -->

</body>
</html>
