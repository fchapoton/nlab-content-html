
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg-flat.dtd" >
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>
      Initiality Project - Raw Syntax in nLab
  </title>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="robots" content="index,follow" />


  <link href="/stylesheets/instiki.css?1534097725" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/mathematics.css?1534319116" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/syntax.css?1531905161" media="all" rel="stylesheet" type="text/css" />
  <style type="text/css">
    h1#pageName, div.info, .newWikiWord a, a.existingWikiWord, .newWikiWord a:hover, [actiontype="toggle"]:hover, #TextileHelp h3 {
      color: #008B26;
    }
    a:visited.existingWikiWord {
      color: #005c19;
    }
    
    
  </style>
  
  <style type="text/css"><!--/*--><![CDATA[/*><!--*/
    .toc ul {margin: 0; padding: 0;}
.toc ul ul {margin: 0; padding: 0 0 0 10px;}
.toc li > p {margin: 0}
.toc ul li {list-style-type: none; position: relative;}
.toc div {border-top:1px dotted #ccc;}
.rightHandSide h2 {font-size: 1.5em;color:#008B26}
table.plaintable {
    border-collapse:collapse;
    margin-left:30px;
    border:0;
}
.plaintable td {border:1px solid #000; padding: 3px;}
.plaintable th {padding: 3px;}
.plaintable caption {
    font-weight: bold;
    font-size:1.1em;
    text-align:center;
    margin-left:30px;
}
    
   
/* Query boxes for questioning and answering mechanism */
div.query{
background: #f6fff3;
border: solid #ce9;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
max-height: 20em;
overflow: auto;
}

/* Standout boxes for putting important text */
div.standout{
background: #fff1f1;
border: solid black;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
overflow: auto;
}

/* Icon for links to n-category arXiv documents 
 (commented out for now i.e. disabled)
a[href*="http://arxiv.org/"] {
  background-image: url(../files/arXiv_icon.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 22px;
  } */
    
/* Icon for links to n-category cafe posts (disabled) 
a[href*="http://golem.ph.utexas.edu/category"] {
  background-image: url(../files/n-cafe_5.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pdf files (disabled)
a[href$=".pdf"] {
  background-image: url(../files/pdficon_small.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pages, etc. -inside- pdf files (disabled)
a[href*=".pdf#"] {
  background-image: url(../files/pdf_entry.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

a.existingWikiWord {
color: #005000;
}

a.existingWikiWord:visited {
color: #005000;
}


a.existingWikiWord[title] {
border: 0px;
color: #aa0505;
text-decoration: none;
}
    
a.existingWikiWord[title]:visited {
border: 0px;
color: #551111;
text-decoration: none;
}

a[href^="http://"] {
border: 0px;
color: #003399;
}

a[href^="http://"]:visited {
border: 0px;
color: #330066;
}

a[href^="https://"] {
border: 0px;
color: #003399;
}

a[href^="https://"]:visited {
border: 0px;
color: #330066;
}

div.dropDown .hide {
display: none;
}

div.dropDown:hover .hide {
display:block;
}

div.clickDown .hide {
display: none;
}

div.clickDown:focus {
outline:none;
}

div.clickDown:focus .hide, div.clickDown:hover .hide {
display: block;
}

div.clickDown .clickToReveal, div.clickDown:focus .clickToHide {
display:block;
}

div.clickDown:focus .clickToReveal, div.clickDown .clickToHide {
display:none;
}

div.clickDown .clickToReveal:after {
content: "\A(Hover to reveal, click to \"hold\")";
font-size: 60%;
}

div.clickDown .clickToHide:after {
content: "\A(Click to hide)";
font-size: 60%;
}
div.clickDown .clickToHide, div.clickDown .clickToReveal {
white-space: pre-wrap;
}

.un_theorem, .num_theorem, .un_lemma, .num_lemma, .un_prop, .num_prop, .un_cor, .num_cor, .un_defn, .num_defn, .un_example, .num_example, .un_note, .num_note, .un_remark, .num_remark {
margin-left: 1em;
}

span.theorem_label {
margin-left: -1em;
}
.proof span.theorem_label {
margin-left: 0em;
}
:target {
    background-color: #BBBBBB;
    border-radius: 5pt;
    padding: 0 10pt;
}
    
    
    
    
    
    
    
    
    
    
    
  /*]]>*/--></style>
  <script src="/javascripts/prototype.js?1532905251" type="text/javascript"></script>
<script src="/javascripts/effects.js?1532905251" type="text/javascript"></script>
<script src="/javascripts/dragdrop.js?1532905252" type="text/javascript"></script>
<script src="/javascripts/controls.js?1532905250" type="text/javascript"></script>
<script src="/javascripts/application.js?1532905250" type="text/javascript"></script>
  <script src="/javascripts/page_helper.js?1533109147" type="text/javascript"></script>
  <script src="/javascripts/thm_numbering.js?1533108238" type="text/javascript"></script>
  
  <script type="text/x-mathjax-config">
  <!--//--><![CDATA[//><!--
    MathJax.Ajax.config.path["Contrib"] = "/MathJax";
    MathJax.Hub.Config({
      MathML: { useMathMLspacing: true },
      "HTML-CSS": { scale: 90,
                    extensions: ["handle-floats.js"]
      }
    });
    MathJax.Hub.Queue( function () {
       var fos = document.getElementsByTagName('foreignObject');
       for (var i = 0; i < fos.length; i++) {
         MathJax.Hub.Typeset(fos[i]);
       }
    });
  //--><!]]>
  </script>

  <script type="text/javascript">
    <!--//--><![CDATA[//><!--
    window.addEventListener("DOMContentLoaded", function () {
      var div = document.createElement('div');
      var math = document.createElementNS('http://www.w3.org/1998/Math/MathML', 'math');
      document.body.appendChild(div);
      div.appendChild(math);
    // Test for MathML support comparable to WebKit version https://trac.webkit.org/changeset/203640 or higher.
      div.setAttribute('style', 'font-style: italic');
      var mathml_unsupported = !(window.getComputedStyle(div.firstChild).getPropertyValue('font-style') === 'normal');
      div.parentNode.removeChild(div);
      if (mathml_unsupported) {
        // MathML does not seem to be supported...
        var s = document.createElement('script');
        s.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=MML_HTMLorMML-full";
        document.querySelector('head').appendChild(s);
      } else {
        document.head.insertAdjacentHTML("beforeend", '<style>svg[viewBox] {max-width: 100%}</style>');
      }
    });
    //--><!]]>
  </script>

  	<link href="https://ncatlab.org/nlab/atom_with_headlines" rel="alternate" title="Atom with headlines" type="application/atom+xml" />
  	<link href="https://ncatlab.org/nlab/atom_with_content" rel="alternate" title="Atom with full content" type="application/atom+xml" />
  <script type="text/javascript">
  document.observe("dom:loaded", function() {
    generateThmNumbers();
  });
  </script>
</head>

<body>

<div id="Container">
<div id="Content">
  <h1 id="pageName">
    
<span id="svg_logo"><svg version="1.1" width="100%" height="100%" viewBox='0 -1 180 198' xmlns='http://www.w3.org/2000/svg'>
      <path id="svg_logo_path" fill="#008B26" stroke-width='0.5' stroke='#000' d='
        M170,60c4,11-1,20-12,25c-9,4-25,3-20,15c5,5,15,0,24,1c11,1,21,11,14,21c-10,15-35,6-48-1c-5-3-27-23-32-10c-1,13,15,10,22,16
        c11,4,24,14,34,20c12,10,7,25-9,23c-11-1-22-9-30-16c-5-5-13-18-21-9c-2,6,2,11,5,14c9,9,22,14,22,31c-2,8-12,8-18,4c-4-3-9-8-11-13
        c-3-6-5-18-12-18c-14-1-5,28-18,30c-9,2-13-9-12-16c1-14,12-24,21-31c5-4,17-13,10-20c-9-10-19,12-23,16c-7,7-17,16-31,15
        c-9-1-18-9-11-17c5-7,14-4,23-6c6-1,15-8,8-15c-5-6-57,2-42-24c7-12,51,4,61,6c6,1,17,4,18-4c2-11-12-7-21-8c-21-2-49-14-49-34
        c0-5,3-11,8-11C31,42,34,65,42,67c6,1,9-3,8-9C49,49,38,40,40,25c1-5,4-15,13-14c10,2,11,18,13,29c1,8,0,24,7,28c15,0,5-22,4-30
        C74,23,78,7,87,1c8-4,14,1,16,9c2,11-8,21-2,30c8,2,11-6,14-12c9-14,36-18,30,5c-3,9-12,19-21,24c-6,4-22,10-23,19c-2,14,15,2,18-2
        c9-9,20-18,33-22C159,52,166,54,170,60' />
    </svg></span>
      <span class="webName">nLab</span><br />
      Initiality Project - Raw Syntax
  </h1>



<div class="navigation">
    <span class="skipNav"><a href='#navEnd'>Skip the Navigation Links</a> | </span>
    <a href="/nlab/show/HomePage" accesskey="H" title="Home page">Home Page</a> |
    <a href="/nlab/all_pages" accesskey="A" title="List of all pages">All Pages</a> |
    <a href="/nlab/latest_revisions" accesskey="U" title="Latest edits and page creations">Latest Revisions</a> |
    <a href="https://nforum.ncatlab.org/discussion/9180/#Item_43" title="Discuss this page in its dedicated thread on the nForum" style="color: black">Discuss this page</a> |
    <a href="/nlab/feeds" title="Subscribe to changes by Atom">Feeds</a> |
<form accept-charset="utf-8" action="/nlab/search" id="navigationSearchForm" method="get">      <fieldset class="search"><input type="text" id="searchField" name="query" value="Search"
             onfocus="this.value == 'Search' ? this.value = '' : true"
             onblur="this.value == '' ? this.value = 'Search' : true" /></fieldset>
</form>  <span id='navEnd'></span>
</div>






<div id="revision">
    <html xmlns="http://www.w3.org/1999/xhtml" xmlns:svg="http://www.w3.org/2000/svg" xml:lang="en" lang="en">
<head><meta http-equiv="Content-type" content="application/xhtml+xml;charset=utf-8" /><title>Initiality Project - Raw Syntax</title></head>
<body>
<h1 id="initiality_project__raw_syntax">Initiality Project - Raw Syntax</h1>

<p>This page is part of the <a class="existingWikiWord" href="/nlab/show/Initiality+Project">Initiality Project</a>.</p>
<div class='maruku_toc'>
<ul>
<li><a href='#idea'>Idea</a></li>
<li><a href='#variables_and_metavariables'>Variables and meta-variables</a></li>
<li><a href='#constants'>Constants</a></li>
<li><a href='#raw_terms'>Raw terms</a></li>
<ul>
<li><a href='#variables_and_constants'>Variables and constants</a></li>
<li><a href='#types'><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math>-types</a></li>
<li><a href='#others'>Others</a></li>
</ul>
<li><a href='#structural_induction'>Structural induction</a></li>
<li><a href='#substitution_and_equivalence'>Substitution and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>-equivalence</a></li>
</ul>
</div>

<h2 id="idea">Idea</h2>

<p>Here we define the “raw syntax” for our type theory. These are sets whose elements are called “raw terms” and “raw types”. They are obtained by putting together operations like “<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>-types” and “<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>-abstraction” in a way that “makes sense locally” but not necessarily globally.</p>

<p>In traditional approaches to logic, one often defines the raw terms (or “well-formed formulas”) as a subset of the set of all “strings”, i.e. finite lists of elements of some “alphabet” set such as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mi>Σ</mi><mo>,</mo><mi>Π</mi><mo>,</mo><mi>λ</mi><mo>,</mo><mo stretchy="false">(</mo><mo>,</mo><mo stretchy="false">)</mo><mo>,</mo><mo>:</mo><mo>,</mo><mi>…</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{\Sigma,\Pi,\lambda,(,),:,\dots \}</annotation></semantics></math>. Note that parentheses, colons, commas, and so on are all symbols in the alphabet. In addition, this point of view requires us to alter some of the clauses to include extra parentheses, e.g. we have to write <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>×</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A\times B)</annotation></semantics></math> so that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>A</mi><mo>×</mo><mi>B</mi><mo stretchy="false">)</mo><mo>×</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">((A\times B)\times C)</annotation></semantics></math> has an unambiguous meaning.</p>

<p>However, a more modern perspective is to regard this as defining an <a class="existingWikiWord" href="/nlab/show/inductive+type">inductive type</a> (in the metatheory), with each clause as a constructor. In this case, the raw terms themselves are not lists of symbols with some property, but rather <em>trees</em> whose nodes are labeled with appropriate symbols. This way we obtain automatically an induction principle for defining functions by recursion and proving theorems by induction over the set of terms, which in the strings-of-symbols approach one has to prove by hand. The strings of symbols we write on the page like <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>×</mo><mi>B</mi><mo stretchy="false">)</mo><mo>×</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">(A\times B)\times C</annotation></semantics></math> are then regarded as just a <em>notation</em> for these “abstract syntax trees”.</p>

<p>It’s true that to be completely precise about the <em>entire</em> passage from “mathematics written on the page” to its meaning, one would want to also define the strings of symbols and prove that they faithfully represent the syntax trees. This is analogous to how a compiler for a programming language must start out by “parsing” and “lexing” the code written by the programmer (which is a string of symbols) into an internal “abstract syntax tree” representation. However, such things are well-understood and extremely uninteresting, so much so that programmers often use “parser generator” programs to <em>write parsers for them</em>; the interesting and nontrivial mathematics starts once we have an abstract syntax tree.</p>

<h2 id="variables_and_metavariables">Variables and meta-variables</h2>

<p>We suppose given an infinite set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Var</mi></mrow><annotation encoding="application/x-tex">Var</annotation></semantics></math>, whose elements we call <em>variables</em>.</p>

<p>Experts will know that there are many ways to deal with variable binding in type theory, including “named variables”, “de Bruijn indices”, “de Bruijn levels”, “locally nameless variables”, and so on. We are using “named variables” (the set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Var</mi></mrow><annotation encoding="application/x-tex">Var</annotation></semantics></math> is the names). The reason is that our goal is expositional and sociological, and named variables keep the syntax as close as possible to what “users” of type theory are familiar with. Since we are humans writing for humans to read, we don’t want to deal explicitly with de Bruijn indices, and neither do we want to pretend that we are using de Bruijn indices when we aren’t <em>really</em> using them.</p>

<p>We will also frequently use <em>meta-variables</em>. These are simply ordinary mathematical variables in the “metatheory”, i.e. the ordinary informal mathematics we are using in which to define and prove things about type theory. Single upper-case roman letters will usually be meta-variables ranging over raw terms or raw types, such as in the inductive clauses below like “if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> are raw types, so is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\times B</annotation></semantics></math>.” Single lower-case roman letters will usually be meta-variables ranging over variables (i.e. elements of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Var</mi></mrow><annotation encoding="application/x-tex">Var</annotation></semantics></math>), as in inductive clauses below such as “if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>,</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A,B</annotation></semantics></math> are raw types, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> is a raw term, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> is a variable, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">)</mo><mo>.</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\lambda (x:A.B). M</annotation></semantics></math> is a raw term.”</p>

<h2 id="constants">Constants</h2>

<p>We suppose given two sets <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>TyCst</mi></mrow><annotation encoding="application/x-tex">TyCst</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>TmCst</mi></mrow><annotation encoding="application/x-tex">TmCst</annotation></semantics></math>, whose elements we call <em>type constants</em> and <em>term constants</em> (sometimes also called “atomic terms” or “axiomatic terms”). We will usually use single upper-case typewriter font letters like <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="monospace"><mi>C</mi></mstyle><mo>,</mo><mstyle mathvariant="monospace"><mi>D</mi></mstyle></mrow><annotation encoding="application/x-tex">\mathtt{C},\mathtt{D}</annotation></semantics></math> for meta-variables ranging over constants.</p>

<h2 id="raw_terms">Raw terms</h2>

<p>Given the set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Var</mi></mrow><annotation encoding="application/x-tex">Var</annotation></semantics></math> of variables and the sets <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>TyCst</mi></mrow><annotation encoding="application/x-tex">TyCst</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>TmCst</mi></mrow><annotation encoding="application/x-tex">TmCst</annotation></semantics></math> of constants, the sets <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>RawTm</mi></mrow><annotation encoding="application/x-tex">RawTm</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>RawTy</mi></mrow><annotation encoding="application/x-tex">RawTy</annotation></semantics></math> of <strong>raw terms</strong> and <strong>raw types</strong> are defined mutually inductively as follows. This can be read as saying that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>RawTm</mi></mrow><annotation encoding="application/x-tex">RawTm</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>RawTy</mi></mrow><annotation encoding="application/x-tex">RawTy</annotation></semantics></math> are sets of well-founded rooted trees in which each node is labeled by one of the following clauses. The children of such a node must correspond to the raw terms or types assumed to be given in that clause, and any other data (such as variables) must be associated to the node as well.</p>

<p>We divide up the clauses according to the type forming operations that may be present in the theory.</p>

<h3 id="variables_and_constants">Variables and constants</h3>

<ul>
<li>Every variable is a raw term.</li>

<li>If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="monospace"><mi>C</mi></mstyle></mrow><annotation encoding="application/x-tex">\mathtt{C}</annotation></semantics></math> is a term constant and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>M</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>M</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">M_1,\dots,M_n</annotation></semantics></math> are raw terms, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="monospace"><mi>C</mi></mstyle><mo stretchy="false">(</mo><msub><mi>M</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>M</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathtt{C}(M_1,\dots, M_n)</annotation></semantics></math> is a raw term.</li>

<li>If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="monospace"><mi>C</mi></mstyle></mrow><annotation encoding="application/x-tex">\mathtt{C}</annotation></semantics></math> is a type constant and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>M</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>M</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">M_1,\dots,M_n</annotation></semantics></math> are raw terms, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="monospace"><mi>C</mi></mstyle><mo stretchy="false">(</mo><msub><mi>M</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>M</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathtt{C}(M_1,\dots, M_n)</annotation></semantics></math> is a raw type.</li>
</ul>

<p>That is, there is a node label called <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>variable</mi></mrow><annotation encoding="application/x-tex">variable</annotation></semantics></math>, and every node labeled <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>variable</mi></mrow><annotation encoding="application/x-tex">variable</annotation></semantics></math> has no children but comes with an additional associated element of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Var</mi></mrow><annotation encoding="application/x-tex">Var</annotation></semantics></math>. Similarly, there are node labels called <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>tmconst</mi></mrow><annotation encoding="application/x-tex">tmconst</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>tyconst</mi></mrow><annotation encoding="application/x-tex">tyconst</annotation></semantics></math>, and every node with these labels has an arbitrary finite number of children and comes with an additional associated element of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>TmCst</mi></mrow><annotation encoding="application/x-tex">TmCst</annotation></semantics></math> or <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>TyCst</mi></mrow><annotation encoding="application/x-tex">TyCst</annotation></semantics></math>.</p>

<p>Note that there are no “type variables”; later on we may introduce universes. Similarly, the arguments of a constant are always terms, not types.</p>

<p>The above clauses also introduce notation for these trees: we will write simply “<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math>” for the tree consisting of a single <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>variable</mi></mrow><annotation encoding="application/x-tex">variable</annotation></semantics></math> node with associated variable <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="monospace"><mi>C</mi></mstyle><mo stretchy="false">(</mo><msub><mi>M</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>M</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathtt{C}(M_1,\dots, M_n)</annotation></semantics></math> for the tree whose root is a constant node with associated constant <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="monospace"><mi>C</mi></mstyle></mrow><annotation encoding="application/x-tex">\mathtt{C}</annotation></semantics></math> and subtrees <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>M</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>M</mi> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">M_1,\dots,M_n</annotation></semantics></math>. (These are the “linear” syntaxes that have to be “parsed” into an abstract syntax tree if implementing type theory on a computer.) Thus, for instance, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="monospace"><mi>C</mi></mstyle><mo stretchy="false">(</mo><mstyle mathvariant="monospace"><mi>D</mi></mstyle><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathtt{C}(\mathtt{D}(x),y)</annotation></semantics></math> represents a tree with four nodes: a root with two children, one of which itself has two children.</p>

<h3 id="types"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math>-types</h3>
<ul>
<li>If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>,</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A,B</annotation></semantics></math> are raw terms and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> is a variable, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">)</mo><mo>.</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\Pi(x:A).B</annotation></semantics></math> is a raw type.</li>

<li>If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>,</mo><mi>B</mi><mo>,</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">A,B,M</annotation></semantics></math> are raw terms and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> is a variable, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">)</mo><mo>.</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\lambda(x:A.B). M</annotation></semantics></math> is a raw term.</li>

<li>If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>,</mo><mi>B</mi><mo>,</mo><mi>M</mi><mo>,</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">A,B,M,N</annotation></semantics></math> are raw terms and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> is a variable, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>App</mi> <mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi></mrow></msup><mo stretchy="false">(</mo><mi>M</mi><mo>,</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">App^{x:A.B}(M,N)</annotation></semantics></math> is a raw term.</li>
</ul>
<h3 id="others">Others</h3>

<p>to be added later…</p>

<h2 id="structural_induction">Structural induction</h2>

<p>The principle of structural induction on raw terms and types says that to prove something about all of them, it suffices to consider raw terms and types constructed according to each of the above clauses (i.e. consider all possible labels for the root of an abstract syntax tree), assuming as an inductive hypothesis that the desired statement holds of all subtrees. This is a basic property of an inductive type; if our metatheory is set-theoretic then it can be proven from the definition of well-founded tree.</p>

<p>Similarly, there is a structural recursion principle for defining pairs of functions with domains <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>RawTm</mi></mrow><annotation encoding="application/x-tex">RawTm</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>RawTy</mi></mrow><annotation encoding="application/x-tex">RawTy</annotation></semantics></math>: to define such a function it suffices to say, for each inductive clause, how to construct the value of the function on a tree with that root, assuming given its values on all the subtrees.</p>

<h2 id="substitution_and_equivalence">Substitution and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>-equivalence</h2>

<p>If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> is a raw term or type, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math> is a raw term, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> is a variable, we will write <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">M[N/x]</annotation></semantics></math> for the raw term or type obtained by “substituting <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math> for all occurrences of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>”. Note that the square brackets are <em>not</em> one of the inductive clauses defining the sets <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>RawTm</mi></mrow><annotation encoding="application/x-tex">RawTm</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>RawTy</mi></mrow><annotation encoding="application/x-tex">RawTy</annotation></semantics></math>; there are no nodes in the abstract syntax tree labeled by them. Instead they are an <em>operation</em> on these sets, i.e. a function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>RawTm</mi><mo>×</mo><mi>RawTm</mi><mo>×</mo><mi>Var</mi><mo>→</mo><mi>RawTm</mi></mrow><annotation encoding="application/x-tex">RawTm \times RawTm \times Var \to RawTm</annotation></semantics></math> and similarly for types.</p>

<p>In terms of abstract syntax trees, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">M[N/x]</annotation></semantics></math> should be obtained by replacing every <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>variable</mi></mrow><annotation encoding="application/x-tex">variable</annotation></semantics></math> node in the tree <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> that is labeled by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> with a copy of the tree <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math>. Such a “naive substitution operation” can be defined quite easily by structural recursion on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>, with clauses such as the following:</p>

<ul>
<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo><mo>=</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">x[N/x] = N</annotation></semantics></math>.</li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">y[N/x] = y</annotation></semantics></math> if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi><mo>≠</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">y\neq x</annotation></semantics></math>.</li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mstyle mathvariant="monospace"><mi>C</mi></mstyle><mo stretchy="false">(</mo><msub><mi>M</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>M</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo><mo>=</mo><mstyle mathvariant="monospace"><mi>C</mi></mstyle><mo stretchy="false">(</mo><msub><mi>M</mi> <mn>1</mn></msub><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>M</mi> <mi>n</mi></msub><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\mathtt{C}(M_1,\dots,M_n))[N/x] = \mathtt{C}(M_1[N/x],\dots,M_n[N/x])</annotation></semantics></math>.</li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>Π</mi><mo stretchy="false">(</mo><mi>y</mi><mo>:</mo><mi>A</mi><mo stretchy="false">)</mo><mo>.</mo><mi>B</mi><mo stretchy="false">)</mo><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo><mo>=</mo><mi>Π</mi><mo stretchy="false">(</mo><mi>y</mi><mo>:</mo><mi>A</mi><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">(\Pi(y:A).B)[N/x] = \Pi(y:A[N/x]).B[N/x]</annotation></semantics></math>.</li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>λ</mi><mo stretchy="false">(</mo><mi>y</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">)</mo><mo>.</mo><mi>M</mi><mo stretchy="false">)</mo><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo><mo>=</mo><mi>λ</mi><mo stretchy="false">(</mo><mi>y</mi><mo>:</mo><mi>A</mi><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>.</mo><mi>M</mi><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">(\lambda(y:A.B). M)[N/x] = \lambda(y:A[N/x].B[N/x]).M[N/x]</annotation></semantics></math>.</li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msup><mi>App</mi> <mrow><mi>y</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi></mrow></msup><mo stretchy="false">(</mo><mi>M</mi><mo>,</mo><mi>P</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo><mo>=</mo><msup><mi>App</mi> <mrow><mi>y</mi><mo>:</mo><mi>A</mi><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo><mo>,</mo><mi>P</mi><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(App^{y:A.B}(M,P))[N/x] = App^{y:A[N/x].B[N/x]}(M[N/x],P[N/x])</annotation></semantics></math>.</li>
</ul>

<p>(These <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>=</mo></mrow><annotation encoding="application/x-tex">=</annotation></semantics></math> signs are literal equalities between raw terms or types, i.e. between elements of the sets <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>RawTm</mi></mrow><annotation encoding="application/x-tex">RawTm</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>RawTy</mi></mrow><annotation encoding="application/x-tex">RawTy</annotation></semantics></math>. <a class="existingWikiWord" href="/nlab/show/Initiality+Project+-+Type+Theory">Later on</a> we will also have judgmental equality and identity types.)</p>

<p>However, this simple definition is not quite what we want <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">M[N/x]</annotation></semantics></math> to mean, because it can result in <em>variable capture</em>. For instance, if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi><mo stretchy="false">(</mo><mi>y</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>A</mi><mo stretchy="false">)</mo><mo>.</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\lambda (y:A.A). x</annotation></semantics></math> (the constant function with value <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math>, which is a free variable) and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math> is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math> (a free variable), then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">M[N/x]</annotation></semantics></math> ought to represent the constant function with value <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math>; but this naive kind of substitution would produce <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi><mo stretchy="false">(</mo><mi>y</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>A</mi><mo stretchy="false">)</mo><mo>.</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">\lambda (y:A.A).y</annotation></semantics></math>, which represents the <em>identity</em> function. The problem is that the variable <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> is “bound” and should not “capture” the free variable <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math>.</p>

<p>A correct definition of substitution must, therefore, distinguish between free and bound variables. We define the set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>FV</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">FV(M)</annotation></semantics></math> of free variables of a raw term or type <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> by structural recursion on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>:</p>

<ul>
<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>FV</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mi>x</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">FV(x) = \{x\}</annotation></semantics></math></li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>FV</mi><mo stretchy="false">(</mo><mstyle mathvariant="monospace"><mi>C</mi></mstyle><mo stretchy="false">(</mo><msub><mi>M</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>M</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>FV</mi><mo stretchy="false">(</mo><msub><mi>M</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo>∪</mo><mi>…</mi><mo>∪</mo><mi>FV</mi><mo stretchy="false">(</mo><msub><mi>M</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">FV(\mathtt{C}(M_1,\dots,M_n)) = FV(M_{1}) \cup \dots \cup FV(M_{n})</annotation></semantics></math></li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>FV</mi><mo stretchy="false">(</mo><mi>Π</mi><mo stretchy="false">(</mo><mi>y</mi><mo>:</mo><mi>A</mi><mo stretchy="false">)</mo><mo>.</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mi>FV</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>∪</mo><mo stretchy="false">(</mo><mi>FV</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo>∖</mo><mo stretchy="false">{</mo><mi>y</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">FV(\Pi(y:A).B) = FV(A) \cup (FV(B) \setminus \{y\})</annotation></semantics></math></li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>FV</mi><mo stretchy="false">(</mo><mi>λ</mi><mo stretchy="false">(</mo><mi>y</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">)</mo><mo>.</mo><mi>M</mi><mo stretchy="false">)</mo><mo>=</mo><mi>FV</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>∪</mo><mo stretchy="false">(</mo><mi>FV</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo>∪</mo><mi>FV</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo><mo>∖</mo><mo stretchy="false">{</mo><mi>y</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">FV(\lambda(y:A.B). M) = FV(A) \cup (FV(B) \cup FV(M) \setminus \{y\})</annotation></semantics></math></li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>FV</mi><mo stretchy="false">(</mo><msup><mi>App</mi> <mrow><mi>y</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi></mrow></msup><mo stretchy="false">(</mo><mi>M</mi><mo>,</mo><mi>P</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>FV</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>∪</mo><mo stretchy="false">(</mo><mi>FV</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo>∖</mo><mo stretchy="false">{</mo><mi>y</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>∪</mo><mi>FV</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo><mo>∪</mo><mi>FV</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">FV(App^{y:A.B}(M,P)) = FV(A) \cup (FV(B) \setminus \{y\}) \cup FV(M) \cup FV(P)</annotation></semantics></math></li>
</ul>

<p>And we define the set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Var</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Var(M)</annotation></semantics></math> for the set of free <em>and</em> bound variables of a raw term by structural induction.</p>

<ul>
<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Var</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mi>x</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">Var(x) = \{x\}</annotation></semantics></math></li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Var</mi><mo stretchy="false">(</mo><mstyle mathvariant="monospace"><mi>C</mi></mstyle><mo stretchy="false">(</mo><msub><mi>M</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>M</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>Var</mi><mo stretchy="false">(</mo><msub><mi>M</mi> <mn>1</mn></msub><mo stretchy="false">)</mo><mo>∪</mo><mi>…</mi><mo>∪</mo><mi>Var</mi><mo stretchy="false">(</mo><msub><mi>M</mi> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Var(\mathtt{C}(M_1,\dots,M_n)) = Var(M_{1}) \cup \dots \cup Var(M_{n})</annotation></semantics></math></li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Var</mi><mo stretchy="false">(</mo><mi>Π</mi><mo stretchy="false">(</mo><mi>y</mi><mo>:</mo><mi>A</mi><mo stretchy="false">)</mo><mo>.</mo><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mi>Var</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>∪</mo><mi>Var</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo>∪</mo><mo stretchy="false">{</mo><mi>y</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Var(\Pi(y:A).B) = Var(A) \cup Var(B) \cup \{y\})</annotation></semantics></math></li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Var</mi><mo stretchy="false">(</mo><mi>λ</mi><mo stretchy="false">(</mo><mi>y</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">)</mo><mo>.</mo><mi>M</mi><mo stretchy="false">)</mo><mo>=</mo><mi>Var</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>∪</mo><mi>Var</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo>∪</mo><mi>Var</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo><mo>∪</mo><mo stretchy="false">{</mo><mi>y</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">Var(\lambda(y:A.B). M) = Var(A) \cup Var(B) \cup Var(M) \cup \{y\}</annotation></semantics></math></li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Var</mi><mo stretchy="false">(</mo><msup><mi>App</mi> <mrow><mi>y</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi></mrow></msup><mo stretchy="false">(</mo><mi>M</mi><mo>,</mo><mi>P</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>Var</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>∪</mo><mi>Var</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo>∪</mo><mo stretchy="false">{</mo><mi>y</mi><mo stretchy="false">}</mo><mo>∪</mo><mi>Var</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo><mo>∪</mo><mi>Var</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Var(App^{y:A.B}(M,P)) = Var(A) \cup Var(B) \cup \{y\} \cup Var(M) \cup Var(P)</annotation></semantics></math></li>
</ul>

<p>Next, we define raw substitution as the following <em>partial</em> function on raw terms. Essentially, we make substitution undefined if there is ever a name clash.</p>

<ul>
<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>y</mi><mo stretchy="false">]</mo><mo>=</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">x[N/y] = N</annotation></semantics></math> if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x = y</annotation></semantics></math>.</li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>y</mi><mo stretchy="false">]</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x[N/y] = x</annotation></semantics></math> if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>≠</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \neq y</annotation></semantics></math>.</li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mstyle mathvariant="monospace"><mi>C</mi></mstyle><mo stretchy="false">(</mo><msub><mi>M</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>M</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>y</mi><mo stretchy="false">]</mo><mo>=</mo><mstyle mathvariant="monospace"><mi>C</mi></mstyle><mo stretchy="false">(</mo><msub><mi>M</mi> <mn>1</mn></msub><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>y</mi><mo stretchy="false">]</mo><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>M</mi> <mi>n</mi></msub><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>y</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\mathtt{C}(M_1,\dots,M_n))[N/y] = \mathtt{C}(M_1[N/y],\dots,M_n[N/y])</annotation></semantics></math>.</li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>Π</mi><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">)</mo><mo>.</mo><mi>B</mi><mo stretchy="false">)</mo><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>y</mi><mo stretchy="false">]</mo><mo>=</mo><mi>Π</mi><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>y</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>y</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">(\Pi(x:A).B)[N/y] = \Pi(x:A[N/y]).B[N/y]</annotation></semantics></math> if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>≠</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \neq y</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>∉</mo><mi>FV</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x \notin FV(N)</annotation></semantics></math></li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>λ</mi><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">)</mo><mo>.</mo><mi>M</mi><mo stretchy="false">)</mo><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>y</mi><mo stretchy="false">]</mo><mo>=</mo><mi>λ</mi><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>y</mi><mo stretchy="false">]</mo><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>y</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>.</mo><mi>M</mi><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>y</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">(\lambda(x:A.B). M)[N/y] = \lambda(x:A[N/y].B[N/y]).M[N/y]</annotation></semantics></math> if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>≠</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \neq y</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>∉</mo><mi>FV</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x \notin FV(N)</annotation></semantics></math></li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><msup><mi>App</mi> <mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi></mrow></msup><mo stretchy="false">(</mo><mi>M</mi><mo>,</mo><mi>P</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>y</mi><mo stretchy="false">]</mo><mo>=</mo><msup><mi>App</mi> <mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>y</mi><mo stretchy="false">]</mo><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>y</mi><mo stretchy="false">]</mo></mrow></msup><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>y</mi><mo stretchy="false">]</mo><mo>,</mo><mi>P</mi><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>y</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(App^{x:A.B}(M,P))[N/y] = App^{x:A[N/y].B[N/y]}(M[N/y],P[N/y])</annotation></semantics></math> if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>≠</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \neq y</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>∉</mo><mi>FV</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x \notin FV(N)</annotation></semantics></math></li>
</ul>

<p>This definition of substitution avoids capture, but it does so at the cost of making substitution a partial function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>RawTm</mi><mo>×</mo><mi>RawTm</mi><mo>×</mo><mi>Var</mi><mo>⇀</mo><mi>RawTm</mi></mrow><annotation encoding="application/x-tex">RawTm \times RawTm \times Var \rightharpoonup RawTm</annotation></semantics></math>. For example, suppose that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">)</mo><mo>.</mo><msup><mi>App</mi> <mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi></mrow></msup><mo stretchy="false">(</mo><mi>f</mi><mo>,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\lambda(x : A.B). App^{x : A.B}(f, x)</annotation></semantics></math>, which is the <a class="existingWikiWord" href="/nlab/show/%CE%B7-expansion">η-expansion</a> of some variable <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math>, and that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math> is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>App</mi> <mrow><mi>z</mi><mo>:</mo><mi>C</mi><mo>.</mo><mo stretchy="false">(</mo><mi>Π</mi><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">)</mo><mo>.</mo><mi>B</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">App^{z: C.(\Pi(x:A).B)}(x, z)</annotation></semantics></math>. Then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>f</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">M[N/f]</annotation></semantics></math> isn’t defined: because <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> is a free variable in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math>.</p>

<p>However, notice that all of the cases where it is undefined depend on the choice of name in a <em>binding</em>, but we want to consider two terms to be equivalent up to re-naming of bound variables. This is the relation of <a class="existingWikiWord" href="/nlab/show/alpha+equivalence"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml">
  <semantics>
    <mrow>
      <mi>α</mi>
    </mrow>
    <annotation encoding="application/x-tex">\alpha</annotation>
  </semantics>
</math>-equivalence</a> on the raw terms and types. We consider <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>RawTm</mi></mrow><annotation encoding="application/x-tex">RawTm</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>RawTy</mi></mrow><annotation encoding="application/x-tex">RawTy</annotation></semantics></math> to be <a class="existingWikiWord" href="/nlab/show/setoids">setoids</a>, i.e. <a class="existingWikiWord" href="/nlab/show/thin+category">thin</a> <a class="existingWikiWord" href="/nlab/show/groupoids">groupoids</a>, under these equivalence relations. Thus all operations on raw terms and types must respect <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>-equivalence, and need only be defined up to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>-equivalence. This will make substitution a <em>total</em> function on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>-equivalence classes because any time it is undefined, there is an <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>-equivalent term for which it is defined.</p>

<p>Note that the definition of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>-equivalence here relies on the definition of substitution that we have defined, at least the special case where the term <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math> being substituted in is a variable. However, we ensure that every time we use substitution, the variable used is different from all free <em>and</em> bound variables, and so the substitution is well defined.</p>

<ul>
<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><msub><mo>∼</mo> <mi>α</mi></msub><mi>x</mi></mrow><annotation encoding="application/x-tex">x \sim_{\alpha} x</annotation></semantics></math></li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="monospace"><mi>C</mi></mstyle><mo stretchy="false">(</mo><msub><mi>M</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>M</mi> <mi>n</mi></msub><mo stretchy="false">)</mo><msub><mo>∼</mo> <mi>α</mi></msub><mstyle mathvariant="monospace"><mi>C</mi></mstyle><mo stretchy="false">(</mo><mi>M</mi><msub><mo>′</mo> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><mi>M</mi><msub><mo>′</mo> <mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathtt{C}(M_1,\dots,M_n) \sim_{\alpha} \mathtt{C}(M'_1,\dots,M'_n)</annotation></semantics></math> if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>M</mi> <mn>1</mn></msub><msub><mo>∼</mo> <mi>α</mi></msub><mi>M</mi><msub><mo>′</mo> <mn>1</mn></msub></mrow><annotation encoding="application/x-tex">M_1 \sim_{\alpha} M'_1</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>…</mi></mrow><annotation encoding="application/x-tex">\dots</annotation></semantics></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>M</mi> <mi>n</mi></msub><msub><mo>∼</mo> <mi>α</mi></msub><mi>M</mi><msub><mo>′</mo> <mi>n</mi></msub></mrow><annotation encoding="application/x-tex">M_n \sim_{\alpha} M'_n</annotation></semantics></math></li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">)</mo><mo>.</mo><mi>B</mi><msub><mo>∼</mo> <mi>α</mi></msub><mi>Π</mi><mo stretchy="false">(</mo><mi>x</mi><mo>′</mo><mo>:</mo><mi>A</mi><mo>′</mo><mo stretchy="false">)</mo><mo>.</mo><mi>B</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">\Pi(x:A).B \sim_{\alpha} \Pi(x':A').B'</annotation></semantics></math> if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><msub><mo>∼</mo> <mi>α</mi></msub><mi>A</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">A \sim_{\alpha} A'</annotation></semantics></math> and for every <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi><mo>∉</mo><mi>Var</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo>∪</mo><mi>Var</mi><mo stretchy="false">(</mo><mi>B</mi><mo>′</mo><mo stretchy="false">)</mo><mo>∪</mo><mo stretchy="false">{</mo><mi>x</mi><mo>,</mo><mi>x</mi><mo>′</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">y \notin
Var(B) \cup Var(B') \cup \{x,x'\}</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi><mo stretchy="false">[</mo><mi>y</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo><msub><mo>∼</mo> <mi>α</mi></msub><mi>B</mi><mo>′</mo><mo stretchy="false">[</mo><mi>y</mi><mo stretchy="false">/</mo><mi>x</mi><mo>′</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">B[y/x] \sim_{\alpha} B'[y/x']</annotation></semantics></math></li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">)</mo><mo>.</mo><mi>M</mi><msub><mo>∼</mo> <mi>α</mi></msub><mi>λ</mi><mo stretchy="false">(</mo><mi>x</mi><mo>′</mo><mo>:</mo><mi>A</mi><mo>′</mo><mo>.</mo><mi>B</mi><mo>′</mo><mo stretchy="false">)</mo><mo>.</mo><mi>M</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">\lambda(x:A.B). M \sim_{\alpha} \lambda(x':A'.B'). M'</annotation></semantics></math> if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">)</mo><mo>.</mo><mi>B</mi><msub><mo>∼</mo> <mi>α</mi></msub><mi>Π</mi><mo stretchy="false">(</mo><mi>x</mi><mo>′</mo><mo>:</mo><mi>A</mi><mo>′</mo><mo stretchy="false">)</mo><mo>.</mo><mi>B</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">\Pi(x:A).B \sim_{\alpha} \Pi(x':A').B'</annotation></semantics></math> and for every <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi><mo>∉</mo><mi>Var</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo><mo>∪</mo><mi>Var</mi><mo stretchy="false">(</mo><mi>M</mi><mo>′</mo><mo stretchy="false">)</mo><mo>∪</mo><mo stretchy="false">{</mo><mi>x</mi><mo>,</mo><mi>x</mi><mo>′</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">y \notin
Var(M) \cup Var(M') \cup \{x,x'\}</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi><mo stretchy="false">[</mo><mi>y</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo><msub><mo>∼</mo> <mi>α</mi></msub><mi>M</mi><mo>′</mo><mo stretchy="false">[</mo><mi>y</mi><mo stretchy="false">/</mo><mi>x</mi><mo>′</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">M[y/x] \sim_{\alpha} M'[y/x']</annotation></semantics></math></li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>App</mi> <mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi></mrow></msup><mo stretchy="false">(</mo><mi>M</mi><mo>,</mo><mi>P</mi><mo stretchy="false">)</mo><msub><mo>∼</mo> <mi>α</mi></msub><msup><mi>App</mi> <mrow><mi>x</mi><mo>′</mo><mo>:</mo><mi>A</mi><mo>′</mo><mo>.</mo><mi>B</mi><mo>′</mo></mrow></msup><mo stretchy="false">(</mo><mi>M</mi><mo>′</mo><mo>,</mo><mi>P</mi><mo>′</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">App^{x:A.B}(M,P) \sim_{\alpha} App^{x':A'.B'}(M',P')</annotation></semantics></math> if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">)</mo><mo>.</mo><mi>B</mi><msub><mo>∼</mo> <mi>α</mi></msub><mi>Π</mi><mo stretchy="false">(</mo><mi>x</mi><mo>′</mo><mo>:</mo><mi>A</mi><mo>′</mo><mo stretchy="false">)</mo><mo>.</mo><mi>B</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">\Pi(x:A).B \sim_{\alpha} \Pi(x':A').B'</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi><msub><mo>∼</mo> <mi>α</mi></msub><mi>M</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">M \sim_{\alpha} M'</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>P</mi><msub><mo>∼</mo> <mi>α</mi></msub><mi>P</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">P \sim_{\alpha} P'</annotation></semantics></math></li>
</ul>

<p>This enables us to extend substitution (uniquely up to unique isomorphism) to a functor, i.e. a setoid morphism, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>RawTm</mi><mo>×</mo><mi>RawTm</mi><mo>×</mo><mi>Var</mi><mo>→</mo><mi>RawTm</mi></mrow><annotation encoding="application/x-tex">RawTm \times RawTm \times Var \to RawTm</annotation></semantics></math> and similarly for types: for substitutions that didn’t used to be defined, modify the term along an <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>-equivalence to eliminate possible variable captures and then do the substitution.</p>

<p>In particular, the substitution <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>λ</mi><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">)</mo><mo>.</mo><msup><mi>App</mi> <mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi></mrow></msup><mo stretchy="false">(</mo><mi>f</mi><mo>,</mo><mi>x</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">[</mo><msup><mi>App</mi> <mrow><mi>z</mi><mo>:</mo><mi>C</mi><mo>.</mo><mo stretchy="false">(</mo><mi>Π</mi><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">)</mo><mo>.</mo><mi>B</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mi>f</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">(\lambda(x : A.B). App^{x:A.B}(f, x))[App^{z:C.(\Pi(x:A).B)}(x, z)/f]</annotation></semantics></math> is now defined. It is equivalent to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>λ</mi><mo stretchy="false">(</mo><mi>w</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>w</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>.</mo><msup><mi>App</mi> <mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi></mrow></msup><mo stretchy="false">(</mo><mi>f</mi><mo>,</mo><mi>w</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">[</mo><msup><mi>App</mi> <mrow><mi>z</mi><mo>:</mo><mi>C</mi><mo>.</mo><mo stretchy="false">(</mo><mi>Π</mi><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">)</mo><mo>.</mo><mi>B</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>z</mi><mo stretchy="false">)</mo><mo stretchy="false">/</mo><mi>f</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">(\lambda(w : A.B[w/x]). App^{x:A.B}(f, w))[App^{z:C.(\Pi(x:A).B)}(x, z)/f]</annotation></semantics></math>, where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>w</mi><mo>∉</mo><mi>FV</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>∪</mo><mi>FV</mi><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo><mo>∪</mo><mi>FV</mi><mo stretchy="false">(</mo><mi>C</mi><mo stretchy="false">)</mo><mo>∪</mo><mo stretchy="false">{</mo><mi>f</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>z</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">w \notin FV(A) \cup FV(B) \cup FV(C) \cup \{f,x,z\}</annotation></semantics></math>, by the second condition on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>∼</mo> <mi>α</mi></msub></mrow><annotation encoding="application/x-tex">\sim_{\alpha}</annotation></semantics></math>, and now the nontrivial case of substitution applies, giving <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>f</mi><mo stretchy="false">]</mo><mo>=</mo><mi>λ</mi><mo stretchy="false">(</mo><mi>w</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">[</mo><mi>w</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>.</mo><msup><mi>App</mi> <mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi></mrow></msup><mo stretchy="false">(</mo><msup><mi>App</mi> <mrow><mi>z</mi><mo>:</mo><mi>C</mi><mo>.</mo><mo stretchy="false">(</mo><mi>Π</mi><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">)</mo><mo>.</mo><mi>B</mi><mo stretchy="false">)</mo></mrow></msup><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>z</mi><mo stretchy="false">)</mo><mo>,</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M[N/f] = \lambda(w : A.B[w/x]). App^{x:A.B}(App^{z:C.(\Pi(x:A).B)}(x, z), w)</annotation></semantics></math>.</p>
<div class="property">category: <a class="category_link" href="/nlab/all_pages/Initiality+Project">Initiality Project</a></div></body></html>

</div>

<div class="revisedby">
  <p>
  Last revised on November  4, 2018 at 06:46:01.
  See the <a href="https://ncatlab.org/nlab/history/Initiality Project - Raw Syntax" style="color: #005c19">history</a> of this page for a list of all contributions to it.
  </p>
</div>

<div class="navigation navfoot">

  <a href="/nlab/edit/Initiality+Project+-+Raw+Syntax" accesskey="E" class="navlink" id="edit" rel="nofollow">Edit</a> | <a href="/nlab/revision/Initiality+Project+-+Raw+Syntax/11" accesskey="B" class="navlink" id="to_previous_revision" rel="nofollow">Back in time</a> <span class='revisions'>(11 revisions)</span> | <a href="/nlab/show/diff/Initiality+Project+-+Raw+Syntax" accesskey="C" class="navlink" id="see_changes" rel="nofollow">See changes</a> | <a href="/nlab/history/Initiality+Project+-+Raw+Syntax" accesskey="S" class="navlink" id="history" rel="nofollow">History</a>
  | <a href="https://ncatlab.org/nlab/show/Initiality Project - Raw Syntax/cite" style="color: black">Cite</a>
  <span class="views">
    | Views:
    <a href="/nlab/print/Initiality+Project+-+Raw+Syntax" accesskey="p" id="view_print" rel="nofollow">Print</a>
    |
    <a href="/nlab/tex/Initiality+Project+-+Raw+Syntax" id="view_tex" rel="nofollow">TeX</a>
    |
    <a href="/nlab/source/Initiality+Project+-+Raw+Syntax" id="view_source" rel="nofollow">Source</a>
  </span>

  


</div>


    <div id="footer">
    <div>This site is running on <a href="http://golem.ph.utexas.edu/instiki/show/HomePage">Instiki 0.19.7(MML+)</a></div>
    <div>Powered by <a href="http://rubyonrails.com/">Ruby on Rails</a>  2.3.18</div>
    </div>

</div> <!-- Content -->

</div> <!-- Container -->

</body>
</html>
