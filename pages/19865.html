
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN" "http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg-flat.dtd" >
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>
      Initiality Project - Raw Syntax in nLab
  </title>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="robots" content="index,follow" />


  <link href="/stylesheets/instiki.css?1534097725" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/mathematics.css?1534319116" media="all" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/syntax.css?1531905161" media="all" rel="stylesheet" type="text/css" />
  <style type="text/css">
    h1#pageName, div.info, .newWikiWord a, a.existingWikiWord, .newWikiWord a:hover, [actiontype="toggle"]:hover, #TextileHelp h3 {
      color: #008B26;
    }
    a:visited.existingWikiWord {
      color: #005c19;
    }
    
    
  </style>
  
  <style type="text/css"><!--/*--><![CDATA[/*><!--*/
    .toc ul {margin: 0; padding: 0;}
.toc ul ul {margin: 0; padding: 0 0 0 10px;}
.toc li > p {margin: 0}
.toc ul li {list-style-type: none; position: relative;}
.toc div {border-top:1px dotted #ccc;}
.rightHandSide h2 {font-size: 1.5em;color:#008B26}
table.plaintable {
    border-collapse:collapse;
    margin-left:30px;
    border:0;
}
.plaintable td {border:1px solid #000; padding: 3px;}
.plaintable th {padding: 3px;}
.plaintable caption {
    font-weight: bold;
    font-size:1.1em;
    text-align:center;
    margin-left:30px;
}
    
   
/* Query boxes for questioning and answering mechanism */
div.query{
background: #f6fff3;
border: solid #ce9;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
max-height: 20em;
overflow: auto;
}

/* Standout boxes for putting important text */
div.standout{
background: #fff1f1;
border: solid black;
border-width: 2px 1px;
padding: 0 1em;
margin: 0 1em;
overflow: auto;
}

/* Icon for links to n-category arXiv documents 
 (commented out for now i.e. disabled)
a[href*="http://arxiv.org/"] {
  background-image: url(../files/arXiv_icon.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 22px;
  } */
    
/* Icon for links to n-category cafe posts (disabled) 
a[href*="http://golem.ph.utexas.edu/category"] {
  background-image: url(../files/n-cafe_5.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pdf files (disabled)
a[href$=".pdf"] {
  background-image: url(../files/pdficon_small.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

/* Icon for links to pages, etc. -inside- pdf files (disabled)
a[href*=".pdf#"] {
  background-image: url(../files/pdf_entry.gif);
  background-repeat: no-repeat;
  background-position: right bottom;
     padding-right: 25px;
  } */

a.existingWikiWord {
color: #005000;
}

a.existingWikiWord:visited {
color: #005000;
}


a.existingWikiWord[title] {
border: 0px;
color: #aa0505;
text-decoration: none;
}
    
a.existingWikiWord[title]:visited {
border: 0px;
color: #551111;
text-decoration: none;
}

a[href^="http://"] {
border: 0px;
color: #003399;
}

a[href^="http://"]:visited {
border: 0px;
color: #330066;
}

a[href^="https://"] {
border: 0px;
color: #003399;
}

a[href^="https://"]:visited {
border: 0px;
color: #330066;
}

div.dropDown .hide {
display: none;
}

div.dropDown:hover .hide {
display:block;
}

div.clickDown .hide {
display: none;
}

div.clickDown:focus {
outline:none;
}

div.clickDown:focus .hide, div.clickDown:hover .hide {
display: block;
}

div.clickDown .clickToReveal, div.clickDown:focus .clickToHide {
display:block;
}

div.clickDown:focus .clickToReveal, div.clickDown .clickToHide {
display:none;
}

div.clickDown .clickToReveal:after {
content: "\A(Hover to reveal, click to \"hold\")";
font-size: 60%;
}

div.clickDown .clickToHide:after {
content: "\A(Click to hide)";
font-size: 60%;
}
div.clickDown .clickToHide, div.clickDown .clickToReveal {
white-space: pre-wrap;
}

.un_theorem, .num_theorem, .un_lemma, .num_lemma, .un_prop, .num_prop, .un_cor, .num_cor, .un_defn, .num_defn, .un_example, .num_example, .un_note, .num_note, .un_remark, .num_remark {
margin-left: 1em;
}

span.theorem_label {
margin-left: -1em;
}
.proof span.theorem_label {
margin-left: 0em;
}
:target {
    background-color: #BBBBBB;
    border-radius: 5pt;
    padding: 0 10pt;
}
    
    
    
    
    
    
    
    
    
    
    
  /*]]>*/--></style>
  <script src="/javascripts/prototype.js?1532905251" type="text/javascript"></script>
<script src="/javascripts/effects.js?1532905251" type="text/javascript"></script>
<script src="/javascripts/dragdrop.js?1532905252" type="text/javascript"></script>
<script src="/javascripts/controls.js?1532905250" type="text/javascript"></script>
<script src="/javascripts/application.js?1532905250" type="text/javascript"></script>
  <script src="/javascripts/page_helper.js?1533109147" type="text/javascript"></script>
  <script src="/javascripts/thm_numbering.js?1533108238" type="text/javascript"></script>
  
  <script type="text/x-mathjax-config">
  <!--//--><![CDATA[//><!--
    MathJax.Ajax.config.path["Contrib"] = "/MathJax";
    MathJax.Hub.Config({
      MathML: { useMathMLspacing: true },
      "HTML-CSS": { scale: 90,
                    extensions: ["handle-floats.js"]
      }
    });
    MathJax.Hub.Queue( function () {
       var fos = document.getElementsByTagName('foreignObject');
       for (var i = 0; i < fos.length; i++) {
         MathJax.Hub.Typeset(fos[i]);
       }
    });
  //--><!]]>
  </script>

  <script type="text/javascript">
    <!--//--><![CDATA[//><!--
    window.addEventListener("DOMContentLoaded", function () {
      var div = document.createElement('div');
      var math = document.createElementNS('http://www.w3.org/1998/Math/MathML', 'math');
      document.body.appendChild(div);
      div.appendChild(math);
    // Test for MathML support comparable to WebKit version https://trac.webkit.org/changeset/203640 or higher.
      div.setAttribute('style', 'font-style: italic');
      var mathml_unsupported = !(window.getComputedStyle(div.firstChild).getPropertyValue('font-style') === 'normal');
      div.parentNode.removeChild(div);
      if (mathml_unsupported) {
        // MathML does not seem to be supported...
        var s = document.createElement('script');
        s.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=MML_HTMLorMML-full";
        document.querySelector('head').appendChild(s);
      } else {
        document.head.insertAdjacentHTML("beforeend", '<style>svg[viewBox] {max-width: 100%}</style>');
      }
    });
    //--><!]]>
  </script>

  	<link href="https://ncatlab.org/nlab/atom_with_headlines" rel="alternate" title="Atom with headlines" type="application/atom+xml" />
  	<link href="https://ncatlab.org/nlab/atom_with_content" rel="alternate" title="Atom with full content" type="application/atom+xml" />
  <script type="text/javascript">
  document.observe("dom:loaded", function() {
    generateThmNumbers();
  });
  </script>
</head>

<body>

<div id="Container">
<div id="Content">
  <h1 id="pageName">
    
<span id="svg_logo"><svg version="1.1" width="100%" height="100%" viewBox='0 -1 180 198' xmlns='http://www.w3.org/2000/svg'>
      <path id="svg_logo_path" fill="#008B26" stroke-width='0.5' stroke='#000' d='
        M170,60c4,11-1,20-12,25c-9,4-25,3-20,15c5,5,15,0,24,1c11,1,21,11,14,21c-10,15-35,6-48-1c-5-3-27-23-32-10c-1,13,15,10,22,16
        c11,4,24,14,34,20c12,10,7,25-9,23c-11-1-22-9-30-16c-5-5-13-18-21-9c-2,6,2,11,5,14c9,9,22,14,22,31c-2,8-12,8-18,4c-4-3-9-8-11-13
        c-3-6-5-18-12-18c-14-1-5,28-18,30c-9,2-13-9-12-16c1-14,12-24,21-31c5-4,17-13,10-20c-9-10-19,12-23,16c-7,7-17,16-31,15
        c-9-1-18-9-11-17c5-7,14-4,23-6c6-1,15-8,8-15c-5-6-57,2-42-24c7-12,51,4,61,6c6,1,17,4,18-4c2-11-12-7-21-8c-21-2-49-14-49-34
        c0-5,3-11,8-11C31,42,34,65,42,67c6,1,9-3,8-9C49,49,38,40,40,25c1-5,4-15,13-14c10,2,11,18,13,29c1,8,0,24,7,28c15,0,5-22,4-30
        C74,23,78,7,87,1c8-4,14,1,16,9c2,11-8,21-2,30c8,2,11-6,14-12c9-14,36-18,30,5c-3,9-12,19-21,24c-6,4-22,10-23,19c-2,14,15,2,18-2
        c9-9,20-18,33-22C159,52,166,54,170,60' />
    </svg></span>
      <span class="webName">nLab</span><br />
      Initiality Project - Raw Syntax
  </h1>



<div class="navigation">
    <span class="skipNav"><a href='#navEnd'>Skip the Navigation Links</a> | </span>
    <a href="/nlab/show/HomePage" accesskey="H" title="Home page">Home Page</a> |
    <a href="/nlab/all_pages" accesskey="A" title="List of all pages">All Pages</a> |
    <a href="/nlab/latest_revisions" accesskey="U" title="Latest edits and page creations">Latest Revisions</a> |
    <a href="https://nforum.ncatlab.org/discussion/9180/#Item_50" title="Discuss this page in its dedicated thread on the nForum" style="color: black">Discuss this page</a> |
    <a href="/nlab/feeds" title="Subscribe to changes by Atom">Feeds</a> |
<form accept-charset="utf-8" action="/nlab/search" id="navigationSearchForm" method="get">      <fieldset class="search"><input type="text" id="searchField" name="query" value="Search"
             onfocus="this.value == 'Search' ? this.value = '' : true"
             onblur="this.value == '' ? this.value = 'Search' : true" /></fieldset>
</form>  <span id='navEnd'></span>
</div>






<div id="revision">
    <html xmlns="http://www.w3.org/1999/xhtml" xmlns:svg="http://www.w3.org/2000/svg" xml:lang="en" lang="en">
<head><meta http-equiv="Content-type" content="application/xhtml+xml;charset=utf-8" /><title>Initiality Project - Raw Syntax</title></head>
<body>
<h1 id="initiality_project__raw_syntax">Initiality Project - Raw Syntax</h1>

<p>This page is part of the <a class="existingWikiWord" href="/nlab/show/Initiality+Project">Initiality Project</a>.</p>
<div class='maruku_toc'>
<ul>
<li><a href='#idea'>Idea</a></li>
<li><a href='#variables_and_metavariables'>Variables and meta-variables</a></li>
<li><a href='#sorts_operators_and_constants'>Sorts, operators, and constants</a></li>
<li><a href='#raw_terms'>Raw terms</a></li>
<li><a href='#operators'>Operators</a></li>
<ul>
<li><a href='#types'><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math>-types</a></li>
<li><a href='#others'>Others</a></li>
</ul>
<li><a href='#structural_induction'>Structural induction</a></li>
<li><a href='#equivalence'><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>-equivalence</a></li>
<li><a href='#weakening_exchange_and_contraction'>Weakening, exchange, and contraction</a></li>
<li><a href='#substitution'>Substitution</a></li>
</ul>
</div>

<h2 id="idea">Idea</h2>

<p>Here we define the “raw syntax” for our type theory. These are sets whose elements are called “raw terms” and “raw types”. They are obtained by putting together operations like “<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math>-types” and “<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>-abstraction” in a way that “makes sense locally” but not necessarily globally.</p>

<p>In traditional approaches to logic, one often defines the raw terms (or “well-formed formulas”) as a subset of the set of all “strings”, i.e. finite lists of elements of some “alphabet” set such as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mi>Σ</mi><mo>,</mo><mi>Π</mi><mo>,</mo><mi>λ</mi><mo>,</mo><mo stretchy="false">(</mo><mo>,</mo><mo stretchy="false">)</mo><mo>,</mo><mo>:</mo><mo>,</mo><mi>…</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{\Sigma,\Pi,\lambda,(,),:,\dots \}</annotation></semantics></math>. Note that parentheses, colons, commas, and so on are all symbols in the alphabet. In addition, this point of view requires us to alter some of the clauses to include extra parentheses, e.g. we have to write <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>×</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A\times B)</annotation></semantics></math> so that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>A</mi><mo>×</mo><mi>B</mi><mo stretchy="false">)</mo><mo>×</mo><mi>C</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">((A\times B)\times C)</annotation></semantics></math> has an unambiguous meaning.</p>

<p>However, a more modern perspective is to regard this as defining an <a class="existingWikiWord" href="/nlab/show/inductive+type">inductive type</a> (in the metatheory), with each clause as a constructor. In this case, the raw terms themselves are not lists of symbols with some property, but rather <em>trees</em> whose nodes are labeled with appropriate symbols. This way we obtain automatically an induction principle for defining functions by recursion and proving theorems by induction over the set of terms, which in the strings-of-symbols approach one has to prove by hand. The strings of symbols we write on the page like <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo>×</mo><mi>B</mi><mo stretchy="false">)</mo><mo>×</mo><mi>C</mi></mrow><annotation encoding="application/x-tex">(A\times B)\times C</annotation></semantics></math> are then regarded as just a <em>notation</em> for these “abstract syntax trees”.</p>

<p>It’s true that to be completely precise about the <em>entire</em> passage from “mathematics written on the page” to its meaning, one would want to also define the strings of symbols and prove that they faithfully represent the syntax trees. This is analogous to how a compiler for a programming language must start out by “parsing” and “lexing” the code written by the programmer (which is a string of symbols) into an internal “abstract syntax tree” representation. However, such things are well-understood and extremely uninteresting, so much so that programmers often use “parser generator” programs to <em>write parsers for them</em>; the interesting and nontrivial mathematics starts once we have an abstract syntax tree.</p>

<h2 id="variables_and_metavariables">Variables and meta-variables</h2>

<p>Experts will know that there are many ways to deal with variable binding in type theory, including “named variables”, “de Bruijn indices”, “de Bruijn levels”, “locally nameless variables”, and so on. We will use “named variables”. The reason is that our goal is expositional and sociological, and named variables keep the syntax as close as possible to what “users” of type theory are familiar with (e.g. with named variables we write <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi><mi>x</mi><mo>.</mo><mi>λ</mi><mi>y</mi><mo>.</mo><mi>App</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\lambda x. \lambda y. App(x,y)</annotation></semantics></math>, whereas with de Bruijn indices one has to write instead <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi><mo>.</mo><mi>λ</mi><mo>.</mo><mi>App</mi><mo stretchy="false">(</mo><mn>2</mn><mo>,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\lambda. \lambda. App(2,1)</annotation></semantics></math>). Since we are humans writing for humans to read, we don’t want to deal explicitly with de Bruijn indices, and neither do we want to pretend that we are using de Bruijn indices when we aren’t <em>really</em> using them.</p>

<p>Thus, we suppose given an infinite set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Var</mi></mrow><annotation encoding="application/x-tex">Var</annotation></semantics></math>, whose elements we call <em>variables</em>. <a class="existingWikiWord" href="/nlab/show/constructive+mathematics">Constructivists</a> should assume that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Var</mi></mrow><annotation encoding="application/x-tex">Var</annotation></semantics></math> has <a class="existingWikiWord" href="/nlab/show/decidable+equality">decidable equality</a>. In addition we assume given an operation <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>fr</mi><mo>:</mo><mi>Var</mi><mo>×</mo><msub><mi>P</mi> <mi>fin</mi></msub><mo stretchy="false">(</mo><mi>Var</mi><mo stretchy="false">)</mo><mo>→</mo><mi>Var</mi></mrow><annotation encoding="application/x-tex">fr : Var \times P_{fin}(Var) \to Var</annotation></semantics></math> which replaces a variable with another one that is “fresh for”, i.e. distinct from all of, a given finite set of variables. That is, we assume that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>fr</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>V</mi><mo stretchy="false">)</mo><mo>∉</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">fr(x,V) \notin V</annotation></semantics></math>. We also assume for simplicity that if already <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>∉</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">x\notin V</annotation></semantics></math> then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>fr</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>V</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">fr(x,V) = x</annotation></semantics></math>. We will also write <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>fr</mi><mo stretchy="false">(</mo><mi>x</mi><mo>,</mo><mi>V</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">fr(x,V)</annotation></semantics></math> as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>x</mi> <mrow><mo stretchy="false">[</mo><mi>V</mi><mo stretchy="false">]</mo></mrow></msup></mrow><annotation encoding="application/x-tex">x^{[V]}</annotation></semantics></math>, and if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">X = \{x_1,\dots,x_n\}</annotation></semantics></math> is a linearly ordered set of variables we will write</p>
<div class="maruku-equation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block" class="maruku-mathml"><semantics><mrow><msup><mi>X</mi> <mrow><mo stretchy="false">[</mo><mi>V</mi><mo stretchy="false">]</mo></mrow></msup><mo>=</mo><mo stretchy="false">{</mo><msubsup><mi>x</mi> <mn>1</mn> <mrow><mo stretchy="false">[</mo><mi>V</mi><mo stretchy="false">]</mo></mrow></msubsup><mo>,</mo><msubsup><mi>x</mi> <mn>2</mn> <mrow><mo stretchy="false">[</mo><mi>V</mi><mo>∪</mo><mo stretchy="false">{</mo><msub><mi>x</mi> <mn>1</mn></msub><mo stretchy="false">}</mo><mo stretchy="false">]</mo></mrow></msubsup><mo>,</mo><mi>…</mi><mo>,</mo><msubsup><mi>x</mi> <mi>n</mi> <mrow><mo stretchy="false">[</mo><mi>V</mi><mo>∪</mo><mo stretchy="false">{</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">}</mo><mo stretchy="false">]</mo></mrow></msubsup><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">X^{[V]} = \{ x_1^{[V]}, x_2^{[V\cup \{x_1\}]}, \dots, x_n^{[V \cup \{x_1,\dots,x_{n-1}\}]}\}</annotation></semantics></math></div>
<p>for the result of freshening each element of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> in succession, ensuring that they remain distinct not only from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> but also from each other.</p>

<p>We will also frequently use <em>meta-variables</em>. These are simply ordinary mathematical variables in the “metatheory”, i.e. the ordinary informal mathematics we are using in which to define and prove things about type theory. Single upper-case roman letters will usually be meta-variables ranging over raw terms or raw types. Single lower-case roman letters will usually be meta-variables ranging over variables (i.e. elements of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Var</mi></mrow><annotation encoding="application/x-tex">Var</annotation></semantics></math>).</p>

<h2 id="sorts_operators_and_constants">Sorts, operators, and constants</h2>

<p>Overall, we are not attempting in this project to treat “all type theories” at any level of generality, instead simply dealing with individual type formers one by one (though attempting to be as “modular” as possible). However, at the level of <em>raw</em> syntax we can easily be fully general, thereby saving ourselves some additional work in each case. Thus, we will work with a variant of what in <a class="existingWikiWord" href="/nlab/show/Practical+Foundations+for+Programming+Languages">Practical Foundations for Programming Languages</a> are called <em>abstract binding trees</em>, parametrized by a set of <em>sorts</em> and a set of <em>operators</em>.</p>

<p>For us the set of <strong>sorts</strong> is <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Sort</mi><mo>=</mo><mo stretchy="false">{</mo><mi>tm</mi><mo>,</mo><mi>ty</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">Sort = \{ tm, ty \}</annotation></semantics></math>. That is, there are two classes of raw syntactic objects: raw terms and raw types. The only function of the notion of “sort” is to avoid writing exactly the same things twice in the two cases.</p>

<p>The set of <strong>operators</strong> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Op</mi></mrow><annotation encoding="application/x-tex">Op</annotation></semantics></math> is a parameter of the theory; the rules for each type former begin by specifying some relevant operators. For instance, the operators associated to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math>-types are <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">{</mo><mi>Π</mi><mo>,</mo><mi>λ</mi><mo>,</mo><mi>App</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{ \Pi, \lambda, App\}</annotation></semantics></math>.</p>

<p>Each operator is furthermore associated with a <strong>signature</strong> or <strong>generalized arity</strong>, which consists of:</p>

<ol>
<li>A sort (i.e. either <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>tm</mi></mrow><annotation encoding="application/x-tex">tm</annotation></semantics></math> or <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ty</mi></mrow><annotation encoding="application/x-tex">ty</annotation></semantics></math>).</li>

<li>A natural number <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>, the <strong>argument arity</strong>.</li>

<li>A <a class="existingWikiWord" href="/nlab/show/function">function</a> from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>=</mo><mo stretchy="false">{</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>n</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">[n]=\{1,\dots,n\}</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Sort</mi></mrow><annotation encoding="application/x-tex">Sort</annotation></semantics></math>, the <strong>argument sorts</strong>.</li>

<li>A natural number <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math>, the <strong>binding arity</strong>.</li>

<li>A <a class="existingWikiWord" href="/nlab/show/relation">relation</a> <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo>⊲</mo></mrow><annotation encoding="application/x-tex">\lhd</annotation></semantics></math> between <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[n]</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>m</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[m]</annotation></semantics></math> called <strong>scoping</strong>. If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>j</mi><mo>⊲</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">j\lhd k</annotation></semantics></math> we say that the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>j</mi> <mi>th</mi></msup></mrow><annotation encoding="application/x-tex">j^{th}</annotation></semantics></math> argument is <em>in the scope of</em> the <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>k</mi> <mi>th</mi></msup></mrow><annotation encoding="application/x-tex">k^{th}</annotation></semantics></math> binder.</li>
</ol>

<p>Often (e.g. in <a class="existingWikiWord" href="/nlab/show/PFPL">PFPL</a>) the scoping relation is a <a class="existingWikiWord" href="/nlab/show/function">function</a> from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>m</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[m]</annotation></semantics></math> to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[n]</annotation></semantics></math>, i.e. each binder has exactly one subterm in its scope. However, it is convenient to be more general; e.g. in a fully-annotated <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>-abstraction <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">)</mo><mo>.</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\lambda(x:A.B).M</annotation></semantics></math> it is natural to consider <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> to be both in the scope of the variable <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math>, rather than requiring this to be desugared to a form such as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi><mo stretchy="false">(</mo><mi>A</mi><mo>,</mo><mi>x</mi><mo>.</mo><mi>B</mi><mo>,</mo><mi>x</mi><mo>′</mo><mo>.</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\lambda(A,x.B,x'.M)</annotation></semantics></math> in which potentially-different variables are bound in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>. Thus, we will represent <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math> as an operator with 3 arguments, two of sort <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ty</mi></mrow><annotation encoding="application/x-tex">ty</annotation></semantics></math> and one of sort <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>tm</mi></mrow><annotation encoding="application/x-tex">tm</annotation></semantics></math>, with binding arity 1, and scoping relations <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>2</mn><mo>⊲</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2\lhd 1</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>3</mn><mo>⊲</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">3\lhd 1</annotation></semantics></math>.</p>

<p>Fully general abstract binding trees also allow each <em>binder</em> to be associated to a sort. However, in our type theories all variables will range only over terms (not types).</p>

<p>Finally, in addition to the operators arising from type formers, we assume a collection of <strong>constants</strong>, each of which is an operator with binding arity <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math> and all arguments having sort <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>tm</mi></mrow><annotation encoding="application/x-tex">tm</annotation></semantics></math>.</p>

<p>We will usually use single upper-case typewriter font letters like <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="monospace"><mi>C</mi></mstyle><mo>,</mo><mstyle mathvariant="monospace"><mi>D</mi></mstyle></mrow><annotation encoding="application/x-tex">\mathtt{C},\mathtt{D}</annotation></semantics></math> for meta-variables ranging over operators, including constants.</p>

<h2 id="raw_terms">Raw terms</h2>

<p>Our raw syntax, though untyped, will be <em>strongly scoped</em>. By this we mean that each raw term or type is indexed by a finite set of variables that may occur in it freely. To be precise, we define inductively a family of sets <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Raw</mi></mrow><annotation encoding="application/x-tex">Raw</annotation></semantics></math> indexed by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>P</mi> <mi>fin</mi></msub><mo stretchy="false">(</mo><mi>Var</mi><mo stretchy="false">)</mo><mo>×</mo><mi>Sort</mi></mrow><annotation encoding="application/x-tex">P_{fin}(Var) \times Sort</annotation></semantics></math>; we call their elements <strong>raw terms/types with variables from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></strong>. Since we are in such generality, there are only two constructors of this inductive family:</p>

<ul>
<li>
<p>For any <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi><mo>∈</mo><msub><mi>P</mi> <mi>fin</mi></msub><mo stretchy="false">(</mo><mi>Var</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V\in P_{fin}(Var)</annotation></semantics></math> and any <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">x\in V</annotation></semantics></math>, we have <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>Raw</mi><mo stretchy="false">(</mo><mi>V</mi><mo>,</mo><mi>tm</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x\in Raw(V,tm)</annotation></semantics></math>.</p>
</li>

<li>
<p>Suppose <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="monospace"><mi>C</mi></mstyle></mrow><annotation encoding="application/x-tex">\mathtt{C}</annotation></semantics></math> is an operator of sort <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math>, argument arity <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math> and binding arity <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math>. Suppose also <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi><mo>,</mo><mi>X</mi><mo>∈</mo><msub><mi>P</mi> <mi>fin</mi></msub><mo stretchy="false">(</mo><mi>Var</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V, X\in P_{fin}(Var)</annotation></semantics></math>, with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi><mo>∩</mo><mi>X</mi><mo>=</mo><mi>∅</mi></mrow><annotation encoding="application/x-tex">V\cap X = \emptyset</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mrow><mo stretchy="false">|</mo><mi>X</mi><mo stretchy="false">|</mo></mrow><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">{|X|} = n</annotation></semantics></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>x</mi> <mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi> <mi>n</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">X = \{x_1,\dots, x_n\}</annotation></semantics></math> totally ordered. Given <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>j</mi><mo>∈</mo><mo stretchy="false">[</mo><mi>m</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">j\in [m]</annotation></semantics></math>, write <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>X</mi> <mi>j</mi></msub><mo>=</mo><mo stretchy="false">{</mo><msub><mi>x</mi> <mi>k</mi></msub><mo lspace="mediummathspace" rspace="mediummathspace">∣</mo><mi>j</mi><mo>⊲</mo><mi>k</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">X_j = \{x_k \mid j \lhd k \}</annotation></semantics></math> for the variables bound in argument <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math>, and suppose furthermore that for each <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>j</mi><mo>∈</mo><mo stretchy="false">[</mo><mi>m</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">j\in [m]</annotation></semantics></math> we have <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>M</mi> <mi>j</mi></msub><mo>∈</mo><mi>Raw</mi><mo stretchy="false">(</mo><mi>V</mi><mo>∪</mo><msub><mi>X</mi> <mi>j</mi></msub><mo>,</mo><msub><mi>t</mi> <mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M_j\in Raw(V\cup X_j, t_j)</annotation></semantics></math>, where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>t</mi><mo>:</mo><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo><mo>→</mo><mi>Sort</mi></mrow><annotation encoding="application/x-tex">t:[n] \to Sort</annotation></semantics></math> gives the argument sorts of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="monospace"><mi>C</mi></mstyle></mrow><annotation encoding="application/x-tex">\mathtt{C}</annotation></semantics></math>. Then we have an element <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="monospace"><mi>C</mi></mstyle><mo stretchy="false">(</mo><mi>X</mi><mo>;</mo><mover><mi>M</mi><mo stretchy="false">→</mo></mover><mo stretchy="false">)</mo><mo>∈</mo><mi>Raw</mi><mo stretchy="false">(</mo><mi>V</mi><mo>,</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathtt{C}(X;\vec{M}) \in Raw(V,s)</annotation></semantics></math>.</p>
</li>
</ul>

<p>This can be read as saying that each set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Raw</mi><mo stretchy="false">(</mo><mi>V</mi><mo>,</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Raw(V,s)</annotation></semantics></math> consists of well-founded rooted trees containing nodes of two kinds:</p>

<ul>
<li>
<p>Nodes labeled by a variable (element of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Var</mi></mrow><annotation encoding="application/x-tex">Var</annotation></semantics></math>) that is either in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> or is bound in some parent of that node and scopes over that node. Such a node has no children and is of sort <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>tm</mi></mrow><annotation encoding="application/x-tex">tm</annotation></semantics></math>.</p>
</li>

<li>
<p>Nodes labeled by an operator and a list of variables of its binding arity that are <em>not</em> in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math> or bound in some parent of that node. Such a node has a number of children equal to the argument arity of its operator label, of appropriate sorts, and each of its variables scopes over the subtrees of those children specified by the scoping relation of its operator label, while its sort is that of its operator label.</p>
</li>
</ul>

<p>The above clauses also introduce notation for these trees: we will write simply “<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math>” for the tree consisting of a single variable node with associated variable <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="monospace"><mi>C</mi></mstyle><mo stretchy="false">(</mo><mi>X</mi><mo>;</mo><mover><mi>M</mi><mo stretchy="false">→</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathtt{C}(X;\vec{M})</annotation></semantics></math> for the tree whose root is an operator node with associated operator <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="monospace"><mi>C</mi></mstyle></mrow><annotation encoding="application/x-tex">\mathtt{C}</annotation></semantics></math>, bound variables <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math>, and subtrees <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mover><mi>M</mi><mo stretchy="false">→</mo></mover></mrow><annotation encoding="application/x-tex">\vec{M}</annotation></semantics></math>. (These are the “linear” syntaxes that have to be “parsed” into an abstract syntax tree if implementing type theory on a computer.) For instance, a fully annotated abstraction <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">)</mo><mo>.</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\lambda(x:A.B).M</annotation></semantics></math> is desugared as <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi><mo stretchy="false">(</mo><mi>x</mi><mo>;</mo><mi>A</mi><mo>,</mo><mi>B</mi><mo>,</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\lambda(x;A,B,M)</annotation></semantics></math>, a node labeled by <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> with three subtrees, two of which are in the scope of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math>.</p>

<p>The requirement that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi><mo>∩</mo><mi>X</mi><mo>=</mo><mi>∅</mi></mrow><annotation encoding="application/x-tex">V\cap X= \emptyset</annotation></semantics></math> amounts to a “local <span class="newWikiWord">Barendregt convention<a href="/nlab/new/Barendregt+convention">?</a></span>” that the names of bound variables can never clash with (or “shadow”) any free variables, where the set of “free variables” is <em>declared</em> for each raw term or type (the set <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math>) rather than extracted by syntactic analysis. Maintaining this convention requires “freshening” when we weaken by adding new unused free variables; see below.</p>

<h2 id="operators">Operators</h2>

<h3 id="types"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math>-types</h3>
<p>There are three operators associated to <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math>-types: <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mo>,</mo><mi>λ</mi><mo>,</mo><mi>App</mi></mrow><annotation encoding="application/x-tex">\Pi,\lambda,App</annotation></semantics></math>.</p><ul>
<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi></mrow><annotation encoding="application/x-tex">\Pi</annotation></semantics></math> is of sort <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ty</mi></mrow><annotation encoding="application/x-tex">ty</annotation></semantics></math>, has two arguments of sort <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ty</mi></mrow><annotation encoding="application/x-tex">ty</annotation></semantics></math>, and one binder that scopes over the second argument. Thus, if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> are raw types and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> is a fresh variable, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Π</mi><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo stretchy="false">)</mo><mo>.</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\Pi(x:A).B</annotation></semantics></math> is a raw type, where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> is bound in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math>.</li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math> is of sort <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>tm</mi></mrow><annotation encoding="application/x-tex">tm</annotation></semantics></math>, has two arguments of sort <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ty</mi></mrow><annotation encoding="application/x-tex">ty</annotation></semantics></math> and one of sort <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>tm</mi></mrow><annotation encoding="application/x-tex">tm</annotation></semantics></math>, and one binder that scopes over the second and third arguments. Thus, if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi><mo>,</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A,B</annotation></semantics></math> are raw types, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> is a raw term and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> is a fresh variable, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>λ</mi><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi><mo stretchy="false">)</mo><mo>.</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">\lambda(x:A.B). M</annotation></semantics></math> is a raw term, where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> is bound in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>.</li>

<li><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>App</mi></mrow><annotation encoding="application/x-tex">App</annotation></semantics></math> is of sort <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>tm</mi></mrow><annotation encoding="application/x-tex">tm</annotation></semantics></math>, has two arguments of sort <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ty</mi></mrow><annotation encoding="application/x-tex">ty</annotation></semantics></math> and two of sort <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>tm</mi></mrow><annotation encoding="application/x-tex">tm</annotation></semantics></math>, and one binder that scopes over the second type argument. Thus, if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> are raw types, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi><mo>,</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">M,N</annotation></semantics></math> are raw terms and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> is a fresh variable, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>App</mi> <mrow><mi>x</mi><mo>:</mo><mi>A</mi><mo>.</mo><mi>B</mi></mrow></msup><mo stretchy="false">(</mo><mi>M</mi><mo>,</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">App^{x:A.B}(M,N)</annotation></semantics></math> is a raw term, where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> is bound in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math> only.</li>
</ul>
<h3 id="others">Others</h3>

<p>to be added later…</p>

<h2 id="structural_induction">Structural induction</h2>

<p>The principle of structural induction on raw terms and types says that to prove something about all of them, it suffices to consider raw terms and types constructed according to each of the above clauses (i.e. consider all possible labels for the root of an abstract syntax tree), assuming as an inductive hypothesis that the desired statement holds of all subtrees. This is a basic property of an inductive type; if our metatheory is set-theoretic then it can be proven from the definition of well-founded tree.</p>

<p>Similarly, there is a structural recursion principle for defining pairs of functions with domains <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>RawTm</mi></mrow><annotation encoding="application/x-tex">RawTm</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>RawTy</mi></mrow><annotation encoding="application/x-tex">RawTy</annotation></semantics></math>: to define such a function it suffices to say, for each inductive clause, how to construct the value of the function on a tree with that root, assuming given its values on all the subtrees.</p>

<h2 id="equivalence"><math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>-equivalence</h2>

<p>We want to identify raw terms and types that differ only according to a renaming of bound variables. However, in defining this inductively, we end up having to also rename <em>free</em> variables in the terms where the variables are bound. We do this all together by defining a relation <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi><msub><mo>∼</mo> <mi>ρ</mi></msub><mi>M</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">M \sim_\rho M'</annotation></semantics></math>, where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi><mo>∈</mo><mi>Raw</mi><mo stretchy="false">(</mo><mi>V</mi><mo>,</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M\in Raw(V,s)</annotation></semantics></math>, <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi><mo>′</mo><mo>∈</mo><mi>Raw</mi><mo stretchy="false">(</mo><mi>V</mi><mo>′</mo><mo>,</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M'\in Raw(V',s)</annotation></semantics></math>, and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho</annotation></semantics></math> is a bijection <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi><mo>≅</mo><mi>V</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">V\cong V'</annotation></semantics></math>, by recursion on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">M'</annotation></semantics></math> as follows:</p>

<ul>
<li>
<p>If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">x\in V</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi><mo>∈</mo><mi>V</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">y\in V'</annotation></semantics></math>, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><msub><mo>∼</mo> <mi>ρ</mi></msub><mi>y</mi></mrow><annotation encoding="application/x-tex">x \sim_\rho y</annotation></semantics></math> if and only if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ρ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">\rho(x)=y</annotation></semantics></math>.</p>
</li>

<li>
<p>For ordered sets <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><mo>,</mo><mi>X</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">X,X'</annotation></semantics></math> of the same cardinality, let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ξ</mi><mo>:</mo><mi>X</mi><mo>≅</mo><mi>X</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">\xi:X\cong X'</annotation></semantics></math> be the unique order-preserving bijection between them, and with <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>X</mi> <mi>j</mi></msub><mo>=</mo><mo stretchy="false">{</mo><msub><mi>x</mi> <mi>k</mi></msub><mo lspace="mediummathspace" rspace="mediummathspace">∣</mo><mi>j</mi><mo>⊲</mo><mi>k</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">X_j = \{x_k \mid j \lhd k \}</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi><msub><mo>′</mo> <mi>j</mi></msub><mo>=</mo><mo stretchy="false">{</mo><mi>x</mi><msub><mo>′</mo> <mi>k</mi></msub><mo lspace="mediummathspace" rspace="mediummathspace">∣</mo><mi>j</mi><mo>⊲</mo><mi>k</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">X'_j = \{x'_k \mid j \lhd k \}</annotation></semantics></math> as before we have similarly <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>ξ</mi> <mi>j</mi></msub><mo>:</mo><msub><mi>X</mi> <mi>j</mi></msub><mo>≅</mo><mi>X</mi><msub><mo>′</mo> <mi>j</mi></msub></mrow><annotation encoding="application/x-tex">\xi_j : X_j \cong X'_j</annotation></semantics></math>. Then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="monospace"><mi>C</mi></mstyle><mo stretchy="false">(</mo><mi>X</mi><mo>;</mo><mover><mi>M</mi><mo stretchy="false">→</mo></mover><mo stretchy="false">)</mo><msub><mo>∼</mo> <mi>ρ</mi></msub><mstyle mathvariant="monospace"><mi>C</mi></mstyle><mo stretchy="false">(</mo><mi>X</mi><mo>′</mo><mo>;</mo><mover><mrow><mi>M</mi><mo>′</mo></mrow><mo stretchy="false">→</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathtt{C}(X;\vec{M}) \sim_{\rho} \mathtt{C}(X';\vec{M'})</annotation></semantics></math> if and only if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>M</mi> <mi>j</mi></msub><msub><mo>∼</mo> <mrow><mi>ρ</mi><mo>∪</mo><msub><mi>ξ</mi> <mi>j</mi></msub></mrow></msub><mi>M</mi><msub><mo>′</mo> <mi>j</mi></msub></mrow><annotation encoding="application/x-tex">M_j \sim_{\rho \cup \xi_j} M'_j</annotation></semantics></math> for all <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math>.</p>
</li>

<li>
<p>In all other cases (e.g. one of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">M'</annotation></semantics></math> is a variable and the other is an operator, or they are distinct operators), <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi><msub><mo>∼</mo> <mi>ρ</mi></msub><mi>M</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">M\sim_\rho M'</annotation></semantics></math> is false.</p>
</li>
</ul>

<p>It is easy to prove by induction that:</p>

<ul>
<li>For any <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi><mo>∈</mo><mi>Raw</mi><mo stretchy="false">(</mo><mi>V</mi><mo>,</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M\in Raw(V,s)</annotation></semantics></math> we have <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi><msub><mo>∼</mo> <mi>id</mi></msub><mi>M</mi></mrow><annotation encoding="application/x-tex">M\sim_{id} M</annotation></semantics></math>.</li>

<li>If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi><msub><mo>∼</mo> <mi>ρ</mi></msub><mi>M</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">M\sim_\rho M'</annotation></semantics></math> then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi><mo>′</mo><msub><mo>∼</mo> <mrow><msup><mi>ρ</mi> <mrow><mo lspace="verythinmathspace" rspace="0em">−</mo><mn>1</mn></mrow></msup></mrow></msub><mi>M</mi></mrow><annotation encoding="application/x-tex">M' \sim_{\rho^{-1}} M</annotation></semantics></math>.</li>

<li>If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi><msub><mo>∼</mo> <mi>ρ</mi></msub><mi>M</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">M\sim_\rho M'</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi><mo>′</mo><msub><mo>∼</mo> <mrow><mi>ρ</mi><mo>′</mo></mrow></msub><mi>M</mi><mo>″</mo></mrow><annotation encoding="application/x-tex">M' \sim_{\rho'} M''</annotation></semantics></math>, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi><msub><mo>∼</mo> <mrow><mi>ρ</mi><mo>′</mo><mo>∘</mo><mi>ρ</mi></mrow></msub><mi>M</mi><mo>″</mo></mrow><annotation encoding="application/x-tex">M\sim_{\rho'\circ\rho} M''</annotation></semantics></math>.</li>
</ul>

<p>In particular, each <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mo>∼</mo> <mi>id</mi></msub></mrow><annotation encoding="application/x-tex">\sim_{id}</annotation></semantics></math> is an equivalence relation on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Raw</mi><mo stretchy="false">(</mo><mi>V</mi><mo>,</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Raw(V,s)</annotation></semantics></math>.</p>

<h2 id="weakening_exchange_and_contraction">Weakening, exchange, and contraction</h2>

<p>For any function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi><mo>:</mo><mi>V</mi><mo>→</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">\sigma :V\to W</annotation></semantics></math>, we define a function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>Raw</mi><mo stretchy="false">(</mo><mi>V</mi><mo>,</mo><mi>s</mi><mo stretchy="false">)</mo><mo>→</mo><mi>Raw</mi><mo stretchy="false">(</mo><mi>W</mi><mo>,</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Raw(V,s) \to Raw(W,s)</annotation></semantics></math>, written <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi><mo>↦</mo><mi>M</mi><mo stretchy="false">[</mo><mi>σ</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">M \mapsto M[\sigma]</annotation></semantics></math>, by induction on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>. When <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math> is a subset inclusion, this is “weakening”: adding a new unused free variable. But to define weakening inductively, we will need to involve <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi><mo stretchy="false">[</mo><mi>σ</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">M[\sigma]</annotation></semantics></math> when <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math> is an injection that is not a subset inclusion, and it is no extra trouble to define it for any function <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math> at all.</p>

<ul>
<li>
<p>If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi><mo>=</mo><mi>x</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">M=x\in V</annotation></semantics></math>, we define <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo stretchy="false">[</mo><mi>σ</mi><mo stretchy="false">]</mo><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x[\sigma] = \sigma(x)</annotation></semantics></math>.</p>
</li>

<li>
<p>If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi><mo>=</mo><mstyle mathvariant="monospace"><mi>C</mi></mstyle><mo stretchy="false">(</mo><mi>X</mi><mo>;</mo><mover><mi>M</mi><mo stretchy="false">→</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M=\mathtt{C}(X;\vec{M})</annotation></semantics></math>, we would like to define <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi><mo stretchy="false">[</mo><mi>σ</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">M[\sigma]</annotation></semantics></math> to be “<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="monospace"><mi>C</mi></mstyle><mo stretchy="false">(</mo><mi>X</mi><mo>;</mo><mover><mi>N</mi><mo stretchy="false">→</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathtt{C}(X;\vec{N})</annotation></semantics></math>” where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>N</mi> <mi>j</mi></msub><mo>=</mo><msub><mi>M</mi> <mi>j</mi></msub><mo stretchy="false">[</mo><mi>σ</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">N_j = M_j[\sigma]</annotation></semantics></math>. But this is not allowed by our definitions, since <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math> may not be disjoint from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math> (though it is disjoint from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math>). Thus, recall that we have the successive freshening <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msup><mi>X</mi> <mrow><mo stretchy="false">[</mo><mi>W</mi><mo stretchy="false">]</mo></mrow></msup></mrow><annotation encoding="application/x-tex">X^{[W]}</annotation></semantics></math> that is disjoint from <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math> and an order-preserving bijection <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ξ</mi><mo>:</mo><mi>X</mi><mo>≅</mo><msup><mi>X</mi> <mrow><mo stretchy="false">[</mo><mi>W</mi><mo stretchy="false">]</mo></mrow></msup></mrow><annotation encoding="application/x-tex">\xi :X \cong X^{[W]}</annotation></semantics></math>. Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>ξ</mi> <mi>j</mi></msub><mo>:</mo><msub><mi>X</mi> <mi>j</mi></msub><mo>≅</mo><msubsup><mi>X</mi> <mi>j</mi> <mrow><mo stretchy="false">[</mo><mi>W</mi><mo stretchy="false">]</mo></mrow></msubsup></mrow><annotation encoding="application/x-tex">\xi_j:X_j \cong X^{[W]}_j</annotation></semantics></math> be the restriction of <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ξ</mi></mrow><annotation encoding="application/x-tex">\xi</annotation></semantics></math> to the variables bound in argument <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math>; then recursively we have <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>M</mi> <mi>j</mi></msub><mo stretchy="false">[</mo><mi>σ</mi><mo>∪</mo><msub><mi>ξ</mi> <mi>j</mi></msub><mo stretchy="false">]</mo><mo>∈</mo><mi>Raw</mi><mo stretchy="false">(</mo><mi>W</mi><mo>∪</mo><msubsup><mi>X</mi> <mi>j</mi> <mrow><mo stretchy="false">[</mo><mi>W</mi><mo stretchy="false">]</mo></mrow></msubsup><mo>,</mo><msub><mi>s</mi> <mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M_j[\sigma\cup \xi_j] \in Raw(W\cup X^{[W]}_j,s_j)</annotation></semantics></math>. If we write <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>N</mi> <mi>j</mi></msub><mo>=</mo><msub><mi>M</mi> <mi>j</mi></msub><mo stretchy="false">[</mo><mi>σ</mi><mo>∪</mo><msub><mi>ξ</mi> <mi>j</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">N_j = M_j[\sigma\cup \xi_j]</annotation></semantics></math>, then we can define <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mstyle mathvariant="monospace"><mi>C</mi></mstyle><mo stretchy="false">(</mo><mi>X</mi><mo>;</mo><mover><mi>M</mi><mo stretchy="false">→</mo></mover><mo stretchy="false">)</mo><mo stretchy="false">[</mo><mi>σ</mi><mo stretchy="false">]</mo><mo>=</mo><mstyle mathvariant="monospace"><mi>C</mi></mstyle><mo stretchy="false">(</mo><msup><mi>X</mi> <mrow><mo stretchy="false">[</mo><mi>W</mi><mo stretchy="false">]</mo></mrow></msup><mo>;</mo><mover><mi>N</mi><mo stretchy="false">→</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathtt{C}(X;\vec{M})[\sigma] = \mathtt{C}(X^{[W]};\vec{N})</annotation></semantics></math>.</p>
</li>
</ul>

<p>It is easy to prove by induction that if <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ρ</mi><mo>,</mo><mi>ρ</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">\rho,\rho'</annotation></semantics></math> are bijections and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>ρ</mi><mo>′</mo><mo>∘</mo><mi>σ</mi><mo>=</mo><mi>σ</mi><mo>′</mo><mo>∘</mo><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\rho' \circ \sigma = \sigma'\circ \rho</annotation></semantics></math>, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi><msub><mo>∼</mo> <mi>ρ</mi></msub><mi>M</mi><mo>′</mo></mrow><annotation encoding="application/x-tex">M\sim_\rho M'</annotation></semantics></math> implies <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi><mo stretchy="false">[</mo><mi>σ</mi><mo stretchy="false">]</mo><msub><mo>∼</mo> <mrow><mi>ρ</mi><mo>′</mo></mrow></msub><mi>M</mi><mo>′</mo><mo stretchy="false">[</mo><mi>σ</mi><mo>′</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">M[\sigma] \sim_{\rho'} M'[\sigma']</annotation></semantics></math>. That is, the structural rules respect <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>-equivalence.</p>

<h2 id="substitution">Substitution</h2>

<p>Let <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>N</mi><mo>∈</mo><mi>Raw</mi><mo stretchy="false">(</mo><mi>V</mi><mo>,</mo><mi>tm</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N\in Raw(V,tm)</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi><mo>∈</mo><mi>Raw</mi><mo stretchy="false">(</mo><mi>V</mi><mo>∪</mo><mo stretchy="false">{</mo><mi>x</mi><mo stretchy="false">}</mo><mo>,</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M\in Raw(V\cup \{x\},s)</annotation></semantics></math> where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo>∉</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">x\notin V</annotation></semantics></math>; we want to define <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo><mo>∈</mo><mi>Raw</mi><mo stretchy="false">(</mo><mi>V</mi><mo>,</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M[N/x] \in Raw(V,s)</annotation></semantics></math> by induction on <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>.</p>

<ul>
<li>
<p>If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">M=x</annotation></semantics></math>, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo><mo>=</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">x[N/x] = N</annotation></semantics></math>; this is well-typed since in this case <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>s</mi><mo>=</mo><mi>tm</mi></mrow><annotation encoding="application/x-tex">s=tm</annotation></semantics></math>.</p>
</li>

<li>
<p>If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">M=y</annotation></semantics></math> for some variable <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">y\in V</annotation></semantics></math>, then <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>y</mi><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">y[N/x] = y</annotation></semantics></math>.</p>
</li>

<li>
<p>If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi><mo>=</mo><mstyle mathvariant="monospace"><mi>C</mi></mstyle><mo stretchy="false">(</mo><mi>X</mi><mo>;</mo><mover><mi>M</mi><mo stretchy="false">→</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M = \mathtt{C}(X;\vec{M})</annotation></semantics></math>, we want to recursively substitute <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math> for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math> in each <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>M</mi> <mi>j</mi></msub></mrow><annotation encoding="application/x-tex">M_j</annotation></semantics></math>. But recall that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>M</mi> <mi>j</mi></msub><mo>∈</mo><mi>Raw</mi><mo stretchy="false">(</mo><mi>V</mi><mo>∪</mo><mo stretchy="false">{</mo><mi>x</mi><mo stretchy="false">}</mo><mo>∪</mo><msub><mi>X</mi> <mi>j</mi></msub><mo>,</mo><msub><mi>s</mi> <mi>j</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M_j \in Raw(V\cup \{x\} \cup X_j,s_j)</annotation></semantics></math>, so in order to write “<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>M</mi> <mi>j</mi></msub><mo stretchy="false">[</mo><msub><mi>N</mi> <mi>j</mi></msub><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">M_j[N_j/x]</annotation></semantics></math>” we need <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>N</mi> <mi>j</mi></msub><mo>∈</mo><mi>Raw</mi><mo stretchy="false">(</mo><mi>V</mi><mo>∪</mo><msub><mi>X</mi> <mi>j</mi></msub><mo>,</mo><mi>tm</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N_j \in Raw(V\cup X_j,tm)</annotation></semantics></math>, whereas we are given only <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>N</mi><mo>∈</mo><mi>Raw</mi><mo stretchy="false">(</mo><mi>V</mi><mo>,</mo><mi>tm</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N\in Raw(V,tm)</annotation></semantics></math>. Thus, we define <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>N</mi> <mi>j</mi></msub><mo>=</mo><mi>N</mi><mo stretchy="false">[</mo><msub><mi>σ</mi> <mi>j</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">N_j = N[\sigma_j]</annotation></semantics></math>, where <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>σ</mi> <mi>j</mi></msub><mo>:</mo><mi>V</mi><mo>→</mo><mi>V</mi><mo>∪</mo><msub><mi>X</mi> <mi>j</mi></msub></mrow><annotation encoding="application/x-tex">\sigma_j:V\to V\cup X_j</annotation></semantics></math> is the obvious inclusion. Then we can define <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><msub><mi>P</mi> <mi>j</mi></msub><mo>=</mo><msub><mi>M</mi> <mi>j</mi></msub><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">[</mo><msub><mi>σ</mi> <mi>j</mi></msub><mo stretchy="false">]</mo><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">P_j = M_j[N[\sigma_j]/x]</annotation></semantics></math> and hence <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo><mo>=</mo><mstyle mathvariant="monospace"><mi>C</mi></mstyle><mo stretchy="false">(</mo><mi>X</mi><mo>;</mo><mover><mi>P</mi><mo stretchy="false">→</mo></mover><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M[N/x] = \mathtt{C}(X;\vec{P})</annotation></semantics></math>.</p>
</li>
</ul>

<p>Note that substitution is automatically “capture-avoiding” because of our “strong scoping” and local Barendregt convention. Before we can write <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">M[N/x]</annotation></semantics></math>, strong scoping requires <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math> to have the same free variables (except for <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math>, which only <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> has), and no bound variables in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> can coincide with these free variables; thus no free variables in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math> can get “captured” when it is substituted under binders in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math>. If <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> and <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math> are not “given” with the same free variables, we need to explicitly weaken them first in order to substitute, and the definition of weakening was forced by strong scoping to rename all bound variables to keep them distinct from the newly added free ones; in particular, the bound variables in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> must get renamed to differ from any free variables in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math>. Finally, the definition of substitution is also forced by strong scoping to rename <em>bound</em> variables in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math> (using the weakening <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mo stretchy="false">[</mo><msub><mi>σ</mi> <mi>j</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[\sigma_j]</annotation></semantics></math>) to keep them distinct from any bound variables in <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math> under which they are substituted, ensuring that <math xmlns="http://www.w3.org/1998/Math/MathML" display="inline" class="maruku-mathml"><semantics><mrow><mi>M</mi><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">/</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">M[N/x]</annotation></semantics></math> still satisfies the Barendregt convention.</p>
<div class="property">category: <a class="category_link" href="/nlab/all_pages/Initiality+Project">Initiality Project</a></div></body></html>

</div>

<div class="revisedby">
  <p>
  Last revised on November  9, 2018 at 14:46:55.
  See the <a href="https://ncatlab.org/nlab/history/Initiality Project - Raw Syntax" style="color: #005c19">history</a> of this page for a list of all contributions to it.
  </p>
</div>

<div class="navigation navfoot">

  <a href="/nlab/edit/Initiality+Project+-+Raw+Syntax" accesskey="E" class="navlink" id="edit" rel="nofollow">Edit</a> | <a href="/nlab/revision/Initiality+Project+-+Raw+Syntax/14" accesskey="B" class="navlink" id="to_previous_revision" rel="nofollow">Back in time</a> <span class='revisions'>(14 revisions)</span> | <a href="/nlab/show/diff/Initiality+Project+-+Raw+Syntax" accesskey="C" class="navlink" id="see_changes" rel="nofollow">See changes</a> | <a href="/nlab/history/Initiality+Project+-+Raw+Syntax" accesskey="S" class="navlink" id="history" rel="nofollow">History</a>
  | <a href="https://ncatlab.org/nlab/show/Initiality Project - Raw Syntax/cite" style="color: black">Cite</a>
  <span class="views">
    | Views:
    <a href="/nlab/print/Initiality+Project+-+Raw+Syntax" accesskey="p" id="view_print" rel="nofollow">Print</a>
    |
    <a href="/nlab/tex/Initiality+Project+-+Raw+Syntax" id="view_tex" rel="nofollow">TeX</a>
    |
    <a href="/nlab/source/Initiality+Project+-+Raw+Syntax" id="view_source" rel="nofollow">Source</a>
  </span>

  


</div>


    <div id="footer">
    <div>This site is running on <a href="http://golem.ph.utexas.edu/instiki/show/HomePage">Instiki 0.19.7(MML+)</a></div>
    <div>Powered by <a href="http://rubyonrails.com/">Ruby on Rails</a>  2.3.18</div>
    </div>

</div> <!-- Content -->

</div> <!-- Container -->

</body>
</html>
